<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yammer&#39;s BLOG</title>
  
  <subtitle>一天不敲代码就难受的小叶</subtitle>
  <link href="https://www.ylq1104.cn/atom.xml" rel="self"/>
  
  <link href="https://www.ylq1104.cn/"/>
  <updated>2025-05-24T05:33:53.400Z</updated>
  <id>https://www.ylq1104.cn/</id>
  
  <author>
    <name>Yammer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lut本科回忆录</title>
    <link href="https://www.ylq1104.cn/posts/34527/"/>
    <id>https://www.ylq1104.cn/posts/34527/</id>
    <published>2025-05-21T04:24:00.000Z</published>
    <updated>2025-05-24T05:33:53.400Z</updated>
    
    <content type="html"><![CDATA[<p>以此篇记录贯穿本科阶段的一条小径</p><span id="more"></span><p>2025.5.21 开篇</p><p>2021年9月的伊始，揣着我的毕业证在疫情管控期间被校车打包进了给我发毕业证的学校。此时的我对未来没有任何打算，仅仅是怀着对崭新生活的期待跨越上千公里背井离乡。推开东三九楼电梯后那爬满烟油的窗户，拍下了在烂理的第一张映衬着火热热情的夕阳。<br><img src="/picture/l1.png" class="lazyload placeholder" data-srcset="/picture/l1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>lxp</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以此篇记录贯穿本科阶段的一条小径&lt;/p&gt;</summary>
    
    
    
    <category term="本科" scheme="https://www.ylq1104.cn/categories/%E6%9C%AC%E7%A7%91/"/>
    
    
    <category term="Life" scheme="https://www.ylq1104.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Tarjan * 4</title>
    <link href="https://www.ylq1104.cn/posts/23160/"/>
    <id>https://www.ylq1104.cn/posts/23160/</id>
    <published>2024-05-14T05:16:58.000Z</published>
    <updated>2024-05-14T05:48:12.318Z</updated>
    
    <content type="html"><![CDATA[<p>关于 $Tarjan$ 的四种常见应用场景</p><span id="more"></span><h3 id="割点："><a href="#割点：" class="headerlink" title="割点："></a>割点：</h3><p><a href="https://www.ylq1104.cn/posts/47101/">割点学习记录</a></p><details><summary>Code</summary><pre><code class="language-cpp">void tarjan(int u, int fa)&#123;  // 割点    def[u] = low[u] = ++ in;    int num = 0;    for(int i = h[u]; ~i; i = ne[i])&#123;        int v = e[i];        if(!def[v])&#123;            num ++;            tarjan(v, u);            low[u] = min(low[u], low[v]);            if(fa != u && low[v] >= def[u] && !ok[u])&#123;                ok[u] = 1;                ans ++;            &#125;        &#125;else if(v != fa)&#123;            low[u] = min(low[u], def[v]);        &#125;    &#125;    if(u == fa && num >= 2 && !ok[u])&#123;        ok[u] = 1;        ans ++;    &#125;&#125;</code></pre></details>去年写过就不赘述了，其中注意的是已经走过的点的更新方式。<h3 id="割边："><a href="#割边：" class="headerlink" title="割边："></a>割边：</h3><p>与割点的性质相同，故名思意将该边删除后将该边存在的一个连通分量分成了两个连通分量。割边的代码与割点一致，区别仅在判断 $if(low[v] &gt; dfn[u])$， 即 $u → v$ 的边是割边无法使得 $v$ 通过其他路径到达 $u$, 这里为了方便记录割边的两个端点，使用链式前向星记录邻接表，并且对于割边的两点标记 $st[i] = st[i ^ 1] = 1$。</p><p><a href="https://www.luogu.com.cn/problem/T103481">洛谷割边模板</a></p><details><summary>Code</summary><pre><code class="language-cpp">void tarjan(int u, int fa)&#123;   //割边    dfn[u] = low[u] = ++ in;    for(int i = h[u]; ~i; i = ne[i])&#123;        int v = e[i];        if(!dfn[v])&#123;            tarjan(v, u);            low[u] = min(low[u], low[v]);            if(low[v] > dfn[u])&#123;                if(!st[i]) ans ++;                st[i] = st[i ^ 1] = 1;            &#125;        &#125;else if(v != fa)&#123;            low[u] = min(low[u], dfn[v]);        &#125;    &#125;&#125;</code></pre></details><h3 id="缩点："><a href="#缩点：" class="headerlink" title="缩点："></a>缩点：</h3><p>缩点即在一个有向图中，将带环路径压缩成一个结点方便后续操作。<br>具体操作是在 $Tarjan$ 的基础上给每个经过的结点入栈，当 $if(low[u] == dfn[u])$ 时说明有一条路径为 $u→v→…→u$,说明存在一个以 $u$ 为起始的环，那么我们就可以将此时的栈顶结点全部标记成统一的标记，以下代码中的标记用 $id[u]$ 表示该结点隶属于哪一组，同一组的结点即可表示为一个环用 $u$ 代替表示即称为缩点。如果环上有权值的话也可以将换上的权值全部转移到 $u$ 上。</p><p><a href="https://www.luogu.com.cn/problem/P3387">洛谷缩点模板</a></p><details><summary>Code</summary><pre><code class="language-cpp">void tarjan(int u)&#123;  // 缩点    dfn[u] = low[u] = ++ in;    sta[++ top] = u; st[u] = 1;    for(int i = h[u]; ~ i; i = ne[i])&#123;        int v = e[i];        if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);        else if(st[v]) low[u] = min(low[u], dfn[v]);    &#125;    if(low[u] == dfn[u])&#123;        int v;        t ++;        do&#123;            v = sta[top --];            st[v] = 0;            id[v] = t;        &#125;while(v != u);    &#125;&#125;</code></pre></details><h3 id="2-sat"><a href="#2-sat" class="headerlink" title="2-sat:"></a>2-sat:</h3><p>有一种抽象的概念，假设 $(a为真 || b 为假)$， 那么我们可以从 $a为假推出b为假$ 和 $b为真推出a为真$ 即 $!a→!b$ 和 $b→a$, 我们可以将这种有向关系转换成一条条的有向边并且标记每个联通块中每个结点的标记，假若 $a和!a$ 属于同种标记则说明 $a和!a$ 同时存在，而实际上这是不可能的，所以最终的条件不能全部满足。</p><p>通过抽象出有向边后，我们通过 $Tarjan$ 的缩点处理连通块，最后查看一个连通块中一个元素的对立两种情况是否会在该连通分量中同时存在而判断若干种逻辑条件能否存在。通过以下模板题练习。</p><p><a href="https://www.luogu.com.cn/problem/P4782">洛谷2-sat模板</a></p><details><summary>Code</summary><pre><code class="language-cpp">#include "bits/stdc++.h"#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define INF 1ll << 30#define ll long longusing namespace std;const int N = 2e6 + 10, MOD = 1e9 + 7;int h[N], ne[N], e[N], cnt;int low[N], dfn[N], st[N], in, sta[N], top, id[N], t;int ans[N];void add(int a, int b)&#123;    e[cnt] = b, ne[cnt] = h[a], h[a] = cnt++;&#125;void tarjan(int u)&#123;    dfn[u] = low[u] = ++ in;    sta[++ top] = u; st[u] = 1;    for(int i = h[u]; ~ i; i = ne[i])&#123;        int v = e[i];        if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);        else if(st[v]) low[u] = min(low[u], dfn[v]);    &#125;    if(low[u] == dfn[u])&#123;        int v;        t ++;        do&#123;            v = sta[top --];            st[v] = 0;            id[v] = t;        &#125;while(v != u);    &#125;&#125;int main()&#123;    // ios::sync_with_stdio(0); cin.tie(0);    memset(h, -1, sizeof h);    int n, m; scanf("%d%d", &n, &m);    while(m --)&#123;        int i, a, j, b; scanf("%d%d%d%d", &i, &a, &j, & b);        add(i * 2 + !a, j * 2 + b);        add(j * 2 + !b, i * 2 + a);    &#125;    for(int i = 2; i < n * 2 + 2; ++ i)&#123;        if(!dfn[i]) tarjan(i);    &#125;    // for(int i = 1; i <= n + n + 1; ++ i) cout << id[i] << " \n"[i == n + n];    for(int i = 1; i <= n; ++ i)&#123;        if(id[i * 2] == id[i * 2 + 1])&#123;            puts("IMPOSSIBLE");            return 0;        &#125;        ans[i] = id[i * 2] > id[i * 2 + 1];    &#125;    puts("POSSIBLE");    for(int i = 1; i <= n; ++ i)&#123;        printf("%d ", ans[i]);    &#125;&#125;</code></pre></details><p><a href="https://www.luogu.com.cn/problem/P5782">2-sat练习题</a></p><details><summary>Code</summary><pre><code class="language-cpp">#include "bits/stdc++.h"#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define INF 1ll << 30#define ll long longusing namespace std;const int N = 2e6 + 10, MOD = 1e9 + 7;int h[N], ne[N], e[N], cnt;int low[N], dfn[N], st[N], in, sta[N], top, id[N], t;int ans[N];void add(int a, int b)&#123;    e[cnt] = b, ne[cnt] = h[a], h[a] = cnt++;&#125;void tarjan(int u)&#123;    dfn[u] = low[u] = ++ in;    sta[++ top] = u; st[u] = 1;    for(int i = h[u]; ~ i; i = ne[i])&#123;        int v = e[i];        if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);        else if(st[v]) low[u] = min(low[u], dfn[v]);    &#125;    if(low[u] == dfn[u])&#123;        int v;        t ++;        do&#123;            v = sta[top --];            st[v] = 0;            id[v] = t;        &#125;while(v != u);    &#125;&#125;int main()&#123;    // ios::sync_with_stdio(0); cin.tie(0);    memset(h, -1, sizeof h);    int n, m; cin >> n >> m;    while(m --)&#123;        int a, b; cin >> a >> b;        add(a, b + ((b & 1) ? 1 : -1));        add(b, a + ((a & 1) ? 1 : -1));    &#125;    for(int i = 1; i <= n * 2; ++ i)&#123;        if(!dfn[i]) tarjan(i);    &#125;<pre><code>for(int i = 1; i &lt;= n; i ++)&#123;    if(id[i * 2] == id[i * 2 - 1])&#123;        puts(&quot;NIE&quot;);        return 0;    &#125;    ans[i] = ((id[i * 2] &lt; id[i * 2 - 1]) ? i * 2 : i * 2 - 1);&#125;for(int i = 1; i &lt;= n; ++ i)&#123;    cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;&#125;</code></pre><p>}<br></code></pre></p></details><p>还有一条Div4的H题<br><a href="https://codeforces.com/contest/1971/problem/H">cf(2-sat)</a></p><details><summary>Code</summary><pre><code class="language-cpp">#include "bits/stdc++.h"#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define INF 1ll << 30#define ll long longusing namespace std;const int N = 2e5 + 10, MOD = 1e9 + 7;int h[N], ne[N], e[N], cnt, t;int low[N], dfn[N], st[N], in, sta[N], top, id[N];void add(int a, int b)&#123;     e[cnt] = b, ne[cnt] = h[a], h[a] = cnt++;&#125;void tarjan(int u)&#123;    dfn[u] = low[u] = ++ in;    sta[++ top] = u; st[u] = 1;    for(int i = h[u]; ~ i; i = ne[i])&#123;        int v = e[i];        if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);        else if(st[v]) low[u] = min(low[u], dfn[v]);    &#125;    if(low[u] == dfn[u])&#123;        int v;        t ++;        while(v = sta[top --])&#123;            id[v] = t;            st[v] = 0;            if(v == u) break;        &#125;    &#125;&#125;void init()&#123;    cnt = in = top = t = 0;    memset(h, -1, sizeof h);    memset(ne, 0, sizeof ne);    memset(st, 0, sizeof st);    memset(e, 0, sizeof e);    memset(dfn, 0, sizeof dfn);    memset(low, 0, sizeof low);    memset(id, 0, sizeof id);&#125;int s[4][510];void solve()&#123;    init();    int n; cin >> n;    for(int i = 1; i <= 3; ++ i)&#123;        for(int j = 1; j <= n; ++ j)&#123;            cin >> s[i][j];        &#125;    &#125;    for(int ii = 1; ii <= n; ++ ii)&#123;        for(int i = 1; i < 3; ++ i)&#123;            for(int j = i + 1; j <= 3; ++ j)&#123;                int u = s[i][ii], v = s[j][ii];                int a = abs(u), b = abs(v);                add(a * 2 + (u < 0), b * 2 + (v > 0));                add(b * 2 + (v < 0), a * 2 + (u > 0));            &#125;        &#125;    &#125;    for(int i = 1; i <= n + n; ++ i)&#123;        if(!dfn[i]) tarjan(i);    &#125;    for(int i = 1; i <= n; ++ i)&#123;        if(id[i * 2] == id[i * 2 + 1]) &#123;            cout << "NO\n";            return ;        &#125;    &#125;    cout << "YES\n";&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin >> n;    while(n--) solve();    return 0;&#125;</code></pre></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于 $Tarjan$ 的四种常见应用场景&lt;/p&gt;</summary>
    
    
    
    <category term="图论" scheme="https://www.ylq1104.cn/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="Tarjan" scheme="https://www.ylq1104.cn/tags/Tarjan/"/>
    
    <category term="2-Sat" scheme="https://www.ylq1104.cn/tags/2-Sat/"/>
    
  </entry>
  
  <entry>
    <title>2024ICPC武汉邀请赛</title>
    <link href="https://www.ylq1104.cn/posts/59785/"/>
    <id>https://www.ylq1104.cn/posts/59785/</id>
    <published>2024-05-07T03:19:23.000Z</published>
    <updated>2024-05-16T03:20:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>备战</p><p>更新至I、K、B、F、E、D、C</p><span id="more"></span><h3 id="I-Cyclic-Apple-Strings"><a href="#I-Cyclic-Apple-Strings" class="headerlink" title="I.Cyclic Apple Strings"></a>I.Cyclic Apple Strings</h3><p>  题意：给定一个 $01$ 串，每次操作可以选择一个连续段使该范围内字符连续左移若干次，求使得整串严格非递减的最少操作数。</p><p>  解：显然统计从左到右需操作的段数即可。</p><details><summary>Code</summary><pre><code class="language-cpp">#include"bits/stdc++.h"using namespace std;#define pb(x) push_back(x)typedef long long ll;const int N = 2e5 + 10, MOD = 1e9 + 7;int main()&#123;    string s; cin >> s;    int n = s.size(), ans = 0;     s = " " + s; s += "1";    for(int i = 1; i <= n; ++ i)&#123;        if(s[i] == '1' && s[i + 1] == '0') ans ++;    &#125;    cout << ans;&#125;</code></pre></details><h3 id="K-Party-Games"><a href="#K-Party-Games" class="headerlink" title="K.Party Games"></a>K.Party Games</h3><p>  题意：定义一个长度为 $n$ 的数组为 $1 - n$ 的排列，两个人轮流进行操作，每次操作可以从该数组的头部或尾部拿走一个数，当且仅当剩下的数组异或和为 $0$ 时判定当前操作人为输。</p><p>  解：通过打表得</p><pre><code class="cpp">i = 1,    sum = 1i = 2,    sum = 3i = 3,    sum = 0i = 4,    sum = 4i = 5,    sum = 1i = 6,    sum = 7i = 7,    sum = 0i = 8,    sum = 8i = 9,    sum = 1i = 10,    sum = 11i = 11,    sum = 0i = 12,    sum = 12i = 13,    sum = 1i = 14,    sum = 15i = 15,    sum = 0i = 16,    sum = 16</code></pre><p>可以发现其中异或和 $sum$ 四个数一个周期，、且 $sum = 1$ 时通过拿走头数字先手必胜， $i\ mod\ 4 = 0$ 时通过拿走队尾数字先手必胜，其余情况先手必败。</p><details><summary>Code</summary><pre><code class="language-cpp">#include "bits/stdc++.h"using namespace std;#define pb(x) push_back(x)typedef long long ll;const int N = 2e5 + 10, MOD = 1e9 + 7;int main()&#123;    int T; cin >> T;    while(T --)&#123;        int x; cin >> x;        if(x % 4 == 0 || x % 4 == 1) cout << "Fluttershy\n";        else cout << "Pinkie Pie\n";    &#125;&#125;</code></pre></details><h3 id="B-Countless-Me"><a href="#B-Countless-Me" class="headerlink" title="B.Countless Me"></a>B.Countless Me</h3><p>  题意：给定长度为 $n$ 的 $a\ (a_i\le1e9)$ 数组，使用不超过 $n$ 次操作，每次操作选择两个不同的元素  $a_i, a_j$ 和一个不大于 $a_j$ 的  $x$ 使得  $a_i = a_i + x, a _j = a_j - x$。 问最终数组的<br>  $按位或$ 后最小值为多少。</p><p>  解：通过 $n$ 次操作我们可以使得数组变成任意的数组组合，且满足于数组的总和 $sum$ 不变。因此我们可以从高到低位判断是否需要在 $1&lt;&lt;i$ 这个位置上放数，一旦放数后即可尽量把  $n$ 个 $1&lt;&lt;i$ 填满即可。</p><details><summary>Code</summary><pre><code class="language-cpp">signed main()&#123;    int ans = 0, sum = 0;    int n; cin >> n;    for(int i = 1; i <= n; ++ i) &#123;        int x; cin >> x;        sum += x;    &#125;    for(int i = 30; i >= 0; -- i)&#123;        int x = 1ll << i;        if(sum > (x - 1) * n)&#123;            int y = sum / x;            sum -= 1ll * x * min(y, n);            ans |= x;        &#125;    &#125;    cout << ans;&#125;</code></pre></details><h3 id="F-Custom-Made-Clothes"><a href="#F-Custom-Made-Clothes" class="headerlink" title="F.Custom-Made Clothes"></a>F.Custom-Made Clothes</h3><h4 id="交互题"><a href="#交互题" class="headerlink" title="交互题"></a>交互题</h4><p>  题意：存在一个 $n*n\ (n\le 1000)$ 的正整数矩阵，其中的正整数满足 $a_{i,j}\ge a_{i,j-1},\ a_{i,j}\ge a_{i - 1,j}$， 最多 $50000$ 次询问，每次询问 $i, j, x$ 返回 $a_{i,j}\le x$ 的结果，求问该矩阵中第 $k$ 大的值。</p><p>  解：间接转化成求矩阵中第 $n * n - k$ 个小的值，可以二分这个答案 $x$, 并根据矩阵的特性每次通过 $n$ 次询问查找矩阵中小于 $x$ 的个数而更新二分边界。</p><details><summary>Code</summary><pre><code class="language-cpp">int n, k; bool ask(int x, int y, int s)&#123;    cout << "? " << x << ' ' << y << ' ' << s << '\n';    int xx; cin >> xx;    return xx;&#125;int ok(int mid)&#123;    int sum = 0;    for(int i = 1, j = n; i <= n; i ++)&#123;        while(j >= 1 && !ask(i, j, mid)) j --;        sum += j;    &#125;    return sum;&#125;int main()&#123;    cin >> n >> k;    k = n * n - k + 1;    // cout << k << '\n';    int l = 1, r = n * n;    while(l < r)&#123;        int mid = l + r >> 1;        if(k > ok(mid)) l = mid + 1;        else r = mid;     &#125;    cout << "! " << l;&#125;</code></pre></details><h3 id="E-Boomerang"><a href="#E-Boomerang" class="headerlink" title="E.Boomerang"></a>E.Boomerang</h3><p>  题意：给定一个 $n$ 大小的无向树，一个谣言起始点 $r$ 和 开始消除谣言的时间 $t_0$，存在谣言的结点每个时间单位向边上的结点扩散， $t_0$ 时间之后可以选择一个结点以个时间单位里  $k$ 的步长向边沿结点辟谣，问分别当 $k=1 \sim n$ 时辟完所有谣的最小时间单位。</p><p>  解：通过根节点 $r$ 预处理求出经过每个时间单位树中被谣言覆盖的直径，随后对于每个 $k$ 二分查找花费最少时间辟谣的时间 $t$，此时答案就是 $t_0 + t$</p><details><summary>Code</summary><pre><code class="language-cpp">#include"bits/stdc++.h"using namespace std;#define pb(x) push_back(x)typedef long long ll;const int N = 2e5 + 10, MOD = 1e9 + 7;vector<int> g[N], g0[N];int dist[N], f[N][30], lg[N], d[N];void build(int u, int pre)&#123;    f[u][0] = pre;    dist[u] = dist[pre] + 1;    g0[dist[u]].push_back(u);    for(int i = 1; f[u][i - 1]; i ++)&#123;        f[u][i] = f[f[u][i - 1]][i - 1];    &#125;    for(auto v: g[u])&#123;        if(v != pre) build(v, u);    &#125;&#125;int lca(int u, int v)&#123;    if(dist[u] < dist[v]) swap(u, v);    while(dist[u] > dist[v]) u = f[u][lg[dist[u] - dist[v]] - 1];    if(u == v) return v;    for(int i = lg[dist[u]] - 1; i >= 0; -- i)&#123;        if(f[u][i] != f[v][i])&#123;            u = f[u][i];            v = f[v][i];        &#125;    &#125;    return f[u][0];&#125;int get(int u, int v)&#123;    int tt = lca(u, v);    return dist[u] + dist[v] - 2 * dist[tt];&#125;int main()&#123;    for(int i = 1; i <= N; ++ i)&#123;        int x = i;        while(x)&#123;            lg[i] ++;            x /= 2;        &#125;    &#125;    int n, r, t0; cin >> n;    for(int i = 1; i < n; ++ i)&#123;        int u, v; cin >> u >> v;        g[u].push_back(v);        g[v].push_back(u);    &#125;    cin >> r >> t0;    dist[0] = -1;    build(r, 0);    for(int i = 1; i <= n; ++ i)&#123;        d[i] = d[i - 1];        if(g0[i].size() != 0)&#123;            int x = g0[i][0];            int mx = d[i] + 1;            for(int j = 1; j < g0[i].size(); ++ j)&#123;                mx = max(mx, get(x, g0[i][j]));            &#125;            d[i] = max(mx, d[i]);        &#125;    &#125;    for(int i = 1; i <= n; ++ i)&#123;        d[i] ++;        // cout << d[i] << " \n"[i == n];    &#125;    for(int i = n + 1; i <= n + n; ++ i) d[i] = d[i - 1];    for(int k = 1; k <= n; ++ k)&#123;        int l = 1, r = n;        while(l < r)&#123;            int mid = l + r >> 1;            if(d[t0 + mid] / 2 <= 1ll * mid * k) r = mid;            else l = mid + 1;        &#125;        cout << t0 + l << " \n"[k == n];    &#125;&#125;</code></pre></details>lca+二分<h3 id="D-ICPC"><a href="#D-ICPC" class="headerlink" title="D.ICPC"></a>D.ICPC</h3><p>题意：有一个长度为 $n$ 的餐桌每个位置有一个权值为 $a_i$ 的食物，初始位于 $s$ 处的小M每秒可以向左或向右移动一个单位并立即吃掉该食物，假设 $F[i][j]$ 表示初始位于位置 $i$ 的小M经过 $j$ 秒吃到权值和最大的值，那么求<br>     $\oplus \ _{i=1}^n$ $(i+\oplus$ $\ _{j=1}^{2n}*F[i][j])$</p><p>解：从公式看出本题的重点在于求出 $F[i][j]$，而思考后显然移动的情况要么一直往一个方向，要么最多折返一次。</p><p>当一直往一个方向时 $F[i][j] = max(sum[i + j] - sum[i - 1], sum[i] - sum[i - j - 1])$, 此时求出直线运动的最大值。</p><p>当折返一次时，$F[i][j] = max(F[i+1][j-1], F[i-1][j-1])$, 由于转移过程中一直调用 $j-1$ 的状态，所以 $j$ 应在第一层枚举。</p><details><summary>Code</summary><pre><code class="language-cpp">#include"bits/stdc++.h"using namespace std;#define pb(x) push_back(x)typedef long long ll;const int N = 2e5 + 10, MOD = 1e9 + 7;ll dp[5010][2 * 5010], sum[N];int main()&#123;    int n; cin >> n;    for(int i = 1; i <= n; ++ i)&#123;        cin >> sum[i];        sum[i] += sum[i - 1];    &#125;    for(int i = 1; i <= n; ++ i)&#123;        dp[i][0] = sum[i] - sum[i - 1];        for(int j = 1; j <= n + n; ++ j)&#123;            dp[i][j] = dp[i][j - 1];            if(i + j <= n + n)&#123;                dp[i][j] = max(dp[i][j],sum[i + j] - sum[i - 1]);            &#125;            if(i - j >= 1)&#123;                dp[i][j] = max(dp[i][j], sum[i] - sum[i - j - 1]);            &#125;        &#125;    &#125;    for(int j = 1; j <= n + n; ++ j)&#123;        for(int i = 1; i <= n; ++ i)&#123;            if(i + 1 <= n)                dp[i][j] = max(dp[i][j], dp[i + 1][j - 1]);            if(i - 1 >= 1)                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);        &#125;    &#125;    ll ans = 0;    for(int i = 1; i <= n; ++ i)&#123;        ll res = 0;        for(int j = 0; j <= n + n; ++ j)&#123;            // cout << dp[i][j] << " \n"[j == n + n];            res ^= 1ll * j * dp[i][j];        &#125;        ans ^= res + i;    &#125;    cout << ans;&#125;</code></pre></details><h3 id="C-TreeBag-and-LIS"><a href="#C-TreeBag-and-LIS" class="headerlink" title="C:TreeBag and LIS"></a>C:TreeBag and LIS</h3><p>题意：给定一个数 $x(x\le 10^13)$， 要求构造一个长度不超过 $10^5$ 的数字序列，使得里面严格递增的所有最长子序列和为 $x$。</p><p>比如 $x=494$，可以构造$001243$，此时序列中$0124+0123+0124+0123=494$。</p><p>发现可以通过012012012012的摆法，使得和为 $(12*等差数列求和数量sum)$，通过在每一对 $”012”$ 后边放 “2”，并且从大到小凑这个 $sum$ 即可。当然这里的前提是将 $x$ 变成 $12$ 的倍数，这里通过暴力枚举三个数即可。<br>不用 $12$ 也可以，下面代码以13为例。</p><details><summary>Code</summary><pre><code class="language-cpp">int main()&#123;    ll x; cin >> x;    string s = "";    if(x == 0) s += '0';    else if(x <= 99910)&#123;        s += '0';        while(x --) s += '1';    &#125;else &#123;        for(int a = 3; a < 10; ++ a)&#123;            for(int b = a + 1; b < 10; ++ b)&#123;                for(int c = b + 1; c < 10; ++ c)&#123;                    int k = a * 100 + b * 10 + c;                    if(x % 13 != 0 && (x - k) % 13 == 0)&#123;                        s += '0' + a;                        s += '0' + b;                        s += '0' + c;                        x -= k;                    &#125;                &#125;            &#125;        &#125;        x /= 13;        int t = 0;        while(1ll * t * (t + 1) * (t + 2) / 6 <= x) t ++;        t --;        x -= 1ll * t * (t + 1) * (t + 2) / 6;        vector<int> p(t + 1);        for(int i = t; i >= 1; -- i)&#123;            ll d = 1ll * (1 + i) * i / 2;            p[i] = x / d;            x -= 1ll * d * p[i];                &#125;        for(int i = 1; i <= t; ++ i)&#123;            s += "013";            while(p[i] --) s += '3';        &#125;    &#125;    cout << s;&#125;</code></pre></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;备战&lt;/p&gt;
&lt;p&gt;更新至I、K、B、F、E、D、C&lt;/p&gt;</summary>
    
    
    
    <category term="ICPC" scheme="https://www.ylq1104.cn/categories/ICPC/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="思维" scheme="https://www.ylq1104.cn/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>划水</title>
    <link href="https://www.ylq1104.cn/posts/53838/"/>
    <id>https://www.ylq1104.cn/posts/53838/</id>
    <published>2023-12-02T02:13:54.000Z</published>
    <updated>2023-12-02T02:25:47.823Z</updated>
    
    <content type="html"><![CDATA[<p>看通信原理去咯~</p><span id="more"></span><p>构造包含 $A$ 个字串 $s$ 的总长度为 $n$ 的字符串的方案数。<br>空间复杂度 $O(2 * A * size(s))$，时间复杂度 $O(n * A * size(s))$<br>这题我们的 $s$ 长度为 $3$， $A$ 为 $3$，那么时间复杂度就简化为了 $O(n)$</p><p><img src="/picture/dpy.png" class="lazyload placeholder" data-srcset="/picture/dpy.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define PII pair&lt;int, int&gt;#define INF 1ll &lt;&lt; 30#define ll long longusing namespace std;const int N = 2e5 + 10, MOD = 1e9 + 7;ll dp[2][4][3], ans = 0;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    dp[0][1][0] = 1;    for(int i = 1; i &lt;= n; ++ i)&#123;        for(int j = 1; j &lt;= 3; ++ j)&#123;            dp[i &amp; 1][j][0] = (dp[!(i &amp; 1)][j - 1][2] + dp[!(i &amp; 1)][j][0] * 25 + dp[!(i &amp; 1)][j][1] * 24 + dp[!(i &amp; 1)][j][2] * 25) % MOD;            dp[i &amp; 1][j][1] = (dp[!(i &amp; 1)][j][1] + dp[!(i &amp; 1)][j][0]) % MOD;            dp[i &amp; 1][j][2] = dp[!(i &amp; 1)][j][1];        &#125;        ans = (ans * 26 + dp[!(i &amp; 1)][3][2]) % MOD;    &#125;    cout &lt;&lt; ans;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;看通信原理去咯~&lt;/p&gt;</summary>
    
    
    
    <category term="动态规划" scheme="https://www.ylq1104.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="状压dp" scheme="https://www.ylq1104.cn/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>快速傅里叶变换</title>
    <link href="https://www.ylq1104.cn/posts/19154/"/>
    <id>https://www.ylq1104.cn/posts/19154/</id>
    <published>2023-10-12T07:31:35.000Z</published>
    <updated>2023-10-12T08:04:59.873Z</updated>
    
    <content type="html"><![CDATA[<p>学了数字信号处理 里的FFT于是上洛谷看了许久的cpp</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3803">洛谷：多项式乘法</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>对于朴素的 $O(n^2)$ 的乘法求多项式显然过不了  $1e6$ 的高时间复杂度， $此时引入离散傅里叶变换(DFT)$ 和 $逆离散傅里叶变换$。<br>我们可以通过简单模拟知道多项式的乘法就是其系数的卷积运算，然后时间域的卷积等于其频域的乘法，即 $f[t] * g[t] = F(jw) .* G(jw) (这里区分 .* 和 * 分别为普通乘法和卷积运算)$。 这里的等式是连续函数的，离散条件下该等式也成立。<br>这里我们过程就是<br> $A和B的多项式系数→(DFT)→A和B的频域形式相乘→(IDFT)→ANSWER的多项式系数$</p><p> 这个过程中，我们 $DFT$ 采用 $FFT$ 进行正转换和逆转换，其中的复杂度为  $O(nlogn)$, 频域相乘的复杂度为  $O(n)$。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>$FFT$ 实际上就是将一整个序列平均分成两个序列进行 $DFT$，发现这俩个部分存在重复的值，便可以不断实现 $O(logn)$ 的划分，最终实现递归。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e6 + 10;const double pi = acos(-1.0);int n, m, r[N], lim = 1, l;struct com&#123;  //结构体实现虚数坐标轴    double x, y;    com(double xx = 0, double yy = 0)&#123;        x = xx; y = yy;    &#125;&#125;a[N], b[N];// 虚数加减乘法的实现com operator + (com a, com b) &#123;return com(a.x + b.x, a.y + b.y);&#125;com operator - (com a, com b) &#123;return com(a.x - b.x, a.y - b.y);&#125;com operator * (com a, com b) &#123;return com(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;void fft(com *x, int type)&#123;    // 由蝶形运算的下标位置对应关系    for(int i = 0; i &lt; lim; ++ i)&#123;        if(r[i] &gt; i) swap(x[i], x[r[i]]);    &#125;    // 枚举每次折中下标    for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1)&#123;        com k(cos(pi / mid), type * sin(pi  / mid)) ;        // 幂次方        for(int R = mid &lt;&lt; 1, j = 0; j &lt; lim; j += R)&#123;            com w(1, 0);             // 幂次方的基底            for(int i = 0; i &lt; mid; ++ i, w = w * k)&#123;                com aa = x[j + i], bb = w * x[j + i + mid];                // 反向递推                x[i + j] = aa + bb;                x[i + j + mid] = aa - bb;            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0; i &lt;= n; ++ i) cin &gt;&gt; a[i].x;    for(int i = 0; i &lt;= m; ++ i) cin &gt;&gt; b[i].x;        //由基2的FFT原理，我们构造一个最小2的幂次    while(lim &lt;= n + m) lim &lt;&lt;= 1, l ++;        // 由蝶形运算法，我们求出每个下标序列二进制的倒序    // 该序列位置的时间域可以求出其二进制倒序位置的频域元素值，IDFT同理也可求出    for(int i = 0; i &lt; lim; ++ i)         r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (l - 1));    fft(a, 1);  // 求出 A 多项式的DFT    fft(b, 1);  // 求出 B 多项式的DFT        // 求出 A B 多项式在频域的相乘    for(int i = 0; i &lt;= lim; ++ i) a[i] = a[i] * b[i];    // 求出 A 多项式的IDFT    fft(a, -1);    for(int i = 0; i &lt;= n + m; ++ i) &#123;        int xx = a[i].x / lim + 0.5;        cout &lt;&lt; xx &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;学了数字信号处理 里的FFT于是上洛谷看了许久的cpp&lt;/p&gt;</summary>
    
    
    
    <category term="多项式" scheme="https://www.ylq1104.cn/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
    <category term="卷积" scheme="https://www.ylq1104.cn/tags/%E5%8D%B7%E7%A7%AF/"/>
    
    <category term="傅里叶变换" scheme="https://www.ylq1104.cn/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营9</title>
    <link href="https://www.ylq1104.cn/posts/47558/"/>
    <id>https://www.ylq1104.cn/posts/47558/</id>
    <published>2023-08-27T02:50:39.000Z</published>
    <updated>2023-08-27T03:02:51.731Z</updated>
    
    <content type="html"><![CDATA[<p>更新至E,D…<br>开学了,只水了签到。</p><span id="more"></span><h3 id="题E："><a href="#题E：" class="headerlink" title="题E："></a>题E：</h3><p>题意：给定一个 $n*m$ 的矩形， 求是否能分成若干个不连续的正方形。</p><p>解：欧几里得的几何解释。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define PII pair&lt;int, int&gt;#define INF 1ll &lt;&lt; 30#define ll long longusing namespace std;const int N = 2e5 + 10, MOD = 1e9 + 7;struct P&#123;    int xx, yy, l;&#125;ans[N];void solve()&#123;    int n, m, t = 0; cin &gt;&gt; n &gt;&gt; m;    int x = 0, y = 0;    while(x &lt; n &amp;&amp; y &lt; m)&#123;        int a = n - x, b = m - y;        if(a == b) &#123;ans[++ t] = &#123;x, y, a&#125;; break;&#125;        if(a &lt; b)&#123;            ans[++ t] = &#123;x, y, a&#125;;            y += a;         &#125;else &#123;            ans[++ t] = &#123;x, y, b&#125;;            x += b;        &#125;    &#125;    cout &lt;&lt; &quot;YES\n&quot;;    cout &lt;&lt; t &lt;&lt; &#39;\n&#39;;    for(int i = 1; i &lt;= t; ++ i)         cout &lt;&lt; ans[i].xx &lt;&lt; &#39; &#39; &lt;&lt; ans[i].yy &lt;&lt; &#39; &#39; &lt;&lt; ans[i].l &lt;&lt; &#39;\n&#39;;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre><h3 id="题D"><a href="#题D" class="headerlink" title="题D:"></a>题D:</h3><p>题意：长度的序列 $a$，问有多少子区间 $[l,r]$，满足区间中的每一个数(原序列第 $i$ 个数，$l\le i\le r$)都不是区间中第 $i-l+1$ 小的数$(n \le 5000)$。</p><p>解：数据量比较小，直接枚举 $dp[i][j]$, 第二维表示差分前缀和，我们用来表示一个第 $i$ 个数是否在某个区间内不满足题目要求。首先我们右移 $r$ 使得 $a[i]$ 是区间最小，此时 $dp[i][l]++, dp[i][r+1]–$。随后移动左边间 $j(1\le j \le i - 1)$, 倘若 $a[j] &gt; a[i]$, 那么我们就可以将 $a[r+1]$ 加入到区间这时候 $i$ 就是区间第二大，以此类推…</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5010;int a[N], dp[N][N];void solve()&#123;    int n, ans = 0; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i) for(int j = 1; j &lt;= n; ++ j) dp[i][j] = 0;    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i];    for(int i = 1; i &lt;= n; ++ i)&#123;        int l = i, r = i;        while(r &lt; n &amp;&amp; a[r + 1] &gt; a[i]) r ++;        dp[i][l] ++, dp[i][r + 1] --;        for(int j = i - 1; j; -- j)&#123;            if(a[j] &gt; a[i])&#123;                l = r = r + 1;                while(r &lt; n &amp;&amp; a[r + 1] &gt; a[i]) r ++;            &#125;            if(l &lt;= n) dp[j][l] ++, dp[j][r + 1] --;        &#125;    &#125;    for(int i = 1; i &lt;= n; ++ i)&#123;        int s = 0;        for(int j = i; j &lt;= n; ++ j)&#123;            s += dp[i][j];            if(s == 0) ans ++;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;&#125;int main()&#123;    ios::sync_with_stdio(0); cin.tie(0);    int T; cin &gt;&gt; T;    while(T --) solve();    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至E,D…&lt;br&gt;开学了,只水了签到。&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="欧几里得" scheme="https://www.ylq1104.cn/tags/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营10</title>
    <link href="https://www.ylq1104.cn/posts/34366/"/>
    <id>https://www.ylq1104.cn/posts/34366/</id>
    <published>2023-08-19T04:49:51.000Z</published>
    <updated>2023-08-19T05:29:30.582Z</updated>
    
    <content type="html"><![CDATA[<p>更新至K,M…<br>robocom只做了个签到，烂！开摆！</p><span id="more"></span><h3 id="题K"><a href="#题K" class="headerlink" title="题K"></a>题K</h3><p>题意：没看懂， 给定 $n, m(1\le n,m \le 20)$</p><p>解：直接求 $(2/n)^m$</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;int main()&#123;    int n, m; cin &gt;&gt; n &gt;&gt; m;    double x = 2.0 / n, ans = 1;    if(n != 1)         for(int i = 1; i &lt;= m; ++ i) ans *= x;    printf(&quot;%.15lf&quot;, ans);&#125;</code></pre><h3 id="题M"><a href="#题M" class="headerlink" title="题M"></a>题M</h3><p>题意：给定一个式子 $a+b=c$,不知道这个式子是否成立，问是否能插入一个 $digit$ 使得等式成立。</p><p>解：因为 $1\le a,b,c \le 1e6$, 每个数模拟插入 $0-9$。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;int get(string s)&#123;    int ans = 0;    for(int i = 0; i &lt; s.size(); ++ i)&#123;        int x = s[i] - &#39;0&#39;;        ans = ans * 10 + x;    &#125;    return ans;&#125;int main()&#123;    string a, b, c, x1, x2; cin &gt;&gt; a &gt;&gt; x1 &gt;&gt; b &gt;&gt; x2 &gt;&gt; c;    int aa = get(a), bb = get(b), cc = get(c);    for(int i = 0; i &lt;= a.size(); ++ i)&#123;        for(char j = &#39;0&#39;; j &lt;= &#39;9&#39;; ++ j)&#123;            string s = a.substr(0, i) + j + a.substr(i);            int k = get(s);            if(k + bb == cc)&#123;                cout &lt;&lt; &quot;Yes\n&quot; &lt;&lt; k &lt;&lt; &quot; + &quot; &lt;&lt; bb &lt;&lt; &quot; = &quot; &lt;&lt; cc &lt;&lt; &#39;\n&#39;;                return 0;            &#125;        &#125;    &#125;    for(int i = 0; i &lt;= b.size(); ++ i)&#123;        for(char j = &#39;0&#39;; j &lt;= &#39;9&#39;; ++ j)&#123;            string s = b.substr(0, i) + j + b.substr(i);            int k = get(s);            if(k + aa == cc)&#123;                cout &lt;&lt; &quot;Yes\n&quot; &lt;&lt; aa &lt;&lt; &quot; + &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; cc &lt;&lt; &#39;\n&#39;;                return 0;            &#125;        &#125;    &#125;    for(int i = 0; i &lt;= c.size(); ++ i)&#123;        for(char j = &#39;0&#39;; j &lt;= &#39;9&#39;; ++ j)&#123;            string s = c.substr(0, i) + j + c.substr(i);            int k = get(s);            if(aa + bb == k)&#123;                cout &lt;&lt; &quot;Yes\n&quot; &lt;&lt; aa &lt;&lt; &quot; + &quot; &lt;&lt; bb &lt;&lt; &quot; = &quot; &lt;&lt; k &lt;&lt; &#39;\n&#39;;                return 0;            &#125;        &#125;    &#125;    cout &lt;&lt; &quot;No&quot;;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至K,M…&lt;br&gt;robocom只做了个签到，烂！开摆！&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营8</title>
    <link href="https://www.ylq1104.cn/posts/30983/"/>
    <id>https://www.ylq1104.cn/posts/30983/</id>
    <published>2023-08-14T12:02:41.000Z</published>
    <updated>2023-08-14T12:05:47.691Z</updated>
    
    <content type="html"><![CDATA[<p>更新至A…</p><span id="more"></span><h3 id="题A"><a href="#题A" class="headerlink" title="题A"></a>题A</h3><p>题意：$n$ 组camp，每组若干个人，问多少人参加了全部camp<br>解：略</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt; p, q;int main()&#123;    int n; cin &gt;&gt; n;    set&lt;string&gt; s;    for(int j = 1; j &lt;= n; ++ j)&#123;        int c; cin &gt;&gt; c;        for(int i = 1; i &lt;= c; ++ i) &#123;            string x; cin &gt;&gt; x;            p[x] ++;            s.insert(x);        &#125;    &#125;    for(auto [x, y]: p) if(y == n) q[x] ++;        cout &lt;&lt; q.size() &lt;&lt; &#39;\n&#39;;    for(auto [x, y]: q) cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至A…&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="分块" scheme="https://www.ylq1104.cn/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营6</title>
    <link href="https://www.ylq1104.cn/posts/48518/"/>
    <id>https://www.ylq1104.cn/posts/48518/</id>
    <published>2023-08-14T10:33:48.000Z</published>
    <updated>2023-08-14T11:36:09.334Z</updated>
    
    <content type="html"><![CDATA[<p>更新至G,E…<br>有点多愁善感了</p><span id="more"></span><h3 id="题G"><a href="#题G" class="headerlink" title="题G"></a>题G</h3><p>题意：给定一个初始集合其中仅有 $x,y(x!=y)$, 可以执行任意次以下两种操作</p><pre><code>1、选择a,b(a!=b),往集合中添加a-b2、选择a,b(a!=b),往集合中添加gcd(|a|,|b|)</code></pre><p>问最终能否得到$z$</p><p>解:当 $z=0$ 时，仅有 $a=0或b=0$时，可以直接得到目标值，否则无法通过相减不同值得到 $0$<br>当 $z!=0$ 时，我们通过 $gcd(a,b)$ 可以得到一系列 $gcd(a,b)$ 的倍数，如果能整除就存在.</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int T; cin &gt;&gt; T;    while(T --)&#123;        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        if(c == 0)&#123;            if(a == 0 || b == 0) cout &lt;&lt; &quot;YES\n&quot;;            else cout &lt;&lt; &quot;NO\n&quot;;        &#125;        else if(c % __gcd(a, b) == 0) cout &lt;&lt; &quot;YES\n&quot;;        else cout &lt;&lt; &quot;NO\n&quot;;    &#125;&#125;</code></pre><h3 id="题E"><a href="#题E" class="headerlink" title="题E"></a>题E</h3><p>题意：给定一个长为 $n$ 的数组 $a$，每次询问给定 $l,r,k$，问能否将 $l-r$ 的区间划分为 $k$ 个部分，且每个部分的和都是偶数 $(1\le n,q \le 10^5, 0\le a_i \le 10^{10}, 1\le l \le r \le n, 1 \le k \le 10^5)$。</p><p>解：因为要满足划分后的每个部分和都是偶数，那么我们可以直接从左到右扫描前缀和，统计到当前的前缀和的偶数和个数和奇数和个数，当且仅当一个区间内的和为偶数且两个奇偶性前缀差 $\ge k$。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define PII pair&lt;int, int&gt;#define INF 1ll &lt;&lt; 30#define ll long longusing namespace std;const int N = 2e5 + 10, MOD = 1e9 + 7;int st[N], s[N];void solve()&#123;    int n, q, t = 0; cin &gt;&gt; n &gt;&gt; q;    for(int i = 1, a = 0, b = 0; i &lt;= n; ++ i)&#123;        int x; cin &gt;&gt; x;         s[i] = s[i - 1] + x;        if(s[i] &amp; 1) st[i] = ++ a;        else st[i] = ++ b;    &#125;    while(q --)&#123;        int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;        if((s[r] - s[l - 1]) % 2 == 0 &amp;&amp; (st[r] - st[l - 1]) &gt;= k)             cout &lt;&lt; &quot;YES\n&quot;;         else cout &lt;&lt; &quot;NO\n&quot;;    &#125;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至G,E…&lt;br&gt;有点多愁善感了&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="前缀和" scheme="https://www.ylq1104.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营7</title>
    <link href="https://www.ylq1104.cn/posts/32071/"/>
    <id>https://www.ylq1104.cn/posts/32071/</id>
    <published>2023-08-09T13:00:00.000Z</published>
    <updated>2023-08-10T07:45:23.545Z</updated>
    
    <content type="html"><![CDATA[<p>更新至M,C…<br>这家呆不下去了，想去学校了</p><span id="more"></span><h3 id="题M"><a href="#题M" class="headerlink" title="题M"></a>题M</h3><p>题意：给定一个数字 $n$，问从 $1$ 到 $n$， $n$ 个数中一共有多少单个数，如 $123$ 由 $1，2，3$ 三个单个数字构成。</p><p>解：我们可以枚举一个数由几个单个数构成，当 $n=1234$ 时, 可以将其拆解为 $0-9$， $10-99$ ， $100-999$， $1000-1234$，那么答案就是 $1*(9-0)+2*(99-10+1)+3*(999-100+1)+4*(1234-1000+1)$。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;int get(int x)&#123;    int k = 0; x /= 10;    while(x)&#123;        k = k * 10 + 9;        x /= 10;    &#125;    return k;&#125;int main()&#123;    int n; cin &gt;&gt; n;    while(n --)&#123;        int x; cin &gt;&gt; x;        ll ans = 0;        for(int i = 1, j = 9; i &lt;= 10; ++ i, j = j * 10 + 9)&#123;            int mx = min(j, x);            ans = ans + 1ll * (mx - get(mx)) * i;            if(mx == x) break;        &#125;        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    &#125;&#125;</code></pre><h3 id="题C"><a href="#题C" class="headerlink" title="题C"></a>题C</h3><p>题意：给定 $n,k$，并且有长为 $n$ 的数组 $A$ 和长为 $n-1$ 的数组 $B$，其中 $A_i\oplus A_{i+1} =B_i$,<br>同时对于数组 $A$，满足 $A_1\le A_2\le \dots\le A_n,0\le A_i,B_i \le 2^{30}$,<br>对于满足的数组 $A$, 求排列第 $k$ 小的数组 $A$</p><p>解：由于 $A_i\oplus A_{i+1} =B_i$，一个 $A_1$ 即可得出所有 $A_i$, 我们求 $B$ 的前缀异或和 $Pre$，那么我们就可以得到 $Pre_i=A_1\oplus A_{i+1}$。<br><img src="/picture/niuke71.png" class="lazyload placeholder" data-srcset="/picture/niuke71.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>由 $Pre_i=A_1\oplus A_{i+1}$ 得 $A_{i+1} = A_1 \oplus Pre_i$,  即 $A_{i} = A_1 \oplus Pre_{i-1}$。<br>我们由 $A_1\le A_2\le \dots\le A_n$, 得 $(A_1\oplus Pre_0) \le (A_1\oplus Pre_1)\le \dots\le (A_1 \oplus Pre_{n-1})$。<br>问题就转成了求第 $k$ 小的 $A_1$。<br>于是，我们便可以枚举 $A_1$ 的每个二进制位，假设 $A_1$ 某个二进制位为 $x$, 如果要满足上面不递减情况的话结果如下。<br><img src="/picture/niuke72.jpg" class="lazyload placeholder" data-srcset="/picture/niuke72.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>即当且仅当 $Pre_i$ 和 $Pre_{i+1}$ 的同一二进制位上两数一样，否则这个 $A_1$ 的这个二进制位就是固定的。最终我们可以知道 $A_1$ 有多少个不固定的二进制位，将其转化为十进制，在满足 $\ge k$ 的条件下，将二进制位补齐乃便是第 $k$ 小的 $A_1$。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define PII pair&lt;int, int&gt;#define INF 1ll &lt;&lt; 30#define ll long longusing namespace std;const int N = 2e6 + 10, MOD = 1e9 + 7;int b[N], a[35], pre[N];void solve()&#123;    ll n, k, num = 1 &lt;&lt; 30, a1 = 0; cin &gt;&gt; n &gt;&gt; k;    for(int i = 1; i &lt; n; ++ i) cin &gt;&gt; b[i]; pre[0] = 0;    for(int i = 1; i &lt; n; ++ i) pre[i] = pre[i - 1] ^ b[i];    for(int i = 0; i &lt;= 30; ++ i) a[i] = -1;    for(int i = 1; i &lt; n; ++ i)&#123;        for(int j = 29; j &gt;= 0; -- j)&#123;            int x = (pre[i - 1] &gt;&gt; j) &amp; 1;            int y = (pre[i] &gt;&gt; j) &amp; 1;            if(x + y == 1)&#123;                if(a[j] == -1) a[j] = x, num /= 2;                else if(a[j] != x)&#123;                    cout &lt;&lt; &quot;-1\n&quot;;                    return ;                &#125;                break;            &#125;        &#125;    &#125;    if(k &gt; num) &#123;cout &lt;&lt; &quot;-1\n&quot;; return ;&#125;     else k --;    for(int i = 0; k; k &gt;&gt;= 1)&#123;        while(a[i] != -1) i ++;        a[i] = k &amp; 1;    &#125;    for(int i = 0; i &lt; 30; ++ i) if(a[i] == 1) a1 += (1 &lt;&lt; i);    for(int i = 1; i &lt;= n; ++ i)&#123;        a1 ^= b[i - 1];        cout &lt;&lt; a1 &lt;&lt; &quot; \n&quot;[i == n];    &#125;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至M,C…&lt;br&gt;这家呆不下去了，想去学校了&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="二进制" scheme="https://www.ylq1104.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营5</title>
    <link href="https://www.ylq1104.cn/posts/48326/"/>
    <id>https://www.ylq1104.cn/posts/48326/</id>
    <published>2023-08-01T05:55:15.000Z</published>
    <updated>2023-08-01T08:21:12.757Z</updated>
    
    <content type="html"><![CDATA[<p>更新至G,D,C,H…</p><span id="more"></span><h3 id="题G"><a href="#题G" class="headerlink" title="题G"></a>题G</h3><p>题意：给定一个只包含 $1,2,3,4$ 的长度为 $n$ 的数组 $a$ 和整数 $k$， 求包含 $1,2,3,4$ 且有  $k$ 个 $4$ 的最短连续区间长度。</p><p>解：双指针。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;int a[N], p[5];int main()&#123;    int n, k, num = 0; cin &gt;&gt; n &gt;&gt; k;    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i];    int ans = n;    for(int l = 1, r = 1; r &lt;= n; ++ r)&#123;        p[a[r]] ++;        while(p[1] &gt;= 1 &amp;&amp; p[2] &gt;= 1 &amp;&amp; p[3] &gt;= 1 &amp;&amp; p[4] &gt;= k &amp;&amp; l &lt;= r)&#123;            ans = min(ans, r - l + 1);            p[a[l]] --;            l ++;        &#125;    &#125;    cout &lt;&lt; ans;&#125;</code></pre><p>用map wa了一发，奇奇怪怪。</p><h3 id="题D"><a href="#题D" class="headerlink" title="题D"></a>题D</h3><p>题意：给定 $k,c,n$ $(1&lt;=k,c,n&lt;=1e9)$, 求有多少对正整数 $a，b$ 满足 $ka+b=c$ 其中 $c=xb，x&gt;=1,gcd(a,b)&gt;=n$。</p><p>解：由题意可得方程 $a=(c-b)/k$, 我们由 $c=xb, x&gt;=1$ 可以枚举 $b$，复杂度为 $O(sqrt(c))$, 然后欧几里得判断。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10, MOD = 1e9 + 7;vector&lt;int&gt; prime;void cal(int x)&#123;    for(int i = 1; i &lt;= x / i; ++ i)&#123;        if(x % i == 0)&#123;            prime.push_back(i);            if(x / i != i) prime.push_back(x / i);        &#125;    &#125;&#125;void solve()&#123;    prime.clear();    int k, c, n, ans = 0; cin &gt;&gt; k &gt;&gt; c &gt;&gt; n;    cal(c);    for(auto &amp;b: prime)&#123;        if((c - b) % k == 0)&#123;            int a = (c - b) / k;            if(a &gt; 0 &amp;&amp; __gcd(a, b) &gt;= n) ans ++;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre><h3 id="题C"><a href="#题C" class="headerlink" title="题C"></a>题C</h3><p>题意：给定一个二分图，图左右两边都有 $n$ 个点，且点的编号是 $1-n$ 和  $n + 1-2n$，若 $(i,j + n)$之间存在边，则 $(j,i +n)$之间不存在边。邻接矩阵给出该图的 $n(n-1)/2$条边。问该图的最大匹配 $(1&lt;=n&lt;=3000)$</p><p>解：根据题目性质，可以将 $(i,j+n)$ 转换为 $(i,j)$，此时该图变成了一个竞赛图，当且仅当一个强连通分量只有两个点的时候答案为 $n-1$,反之为 $n$。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int d[3010];int main()&#123;    ios::sync_with_stdio(0); cin.tie(0);    int n, x = 0, y = 0; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i)&#123;        for(int j = 1; j &lt;= n; ++ j)&#123;            int x; cin &gt;&gt; x;            if(x) d[i] ++;        &#125;    &#125;    sort(d + 1, d + 1 + n);    for(int i = 1, j = 0, s = 0; i &lt;= n; ++ i)&#123;        s += d[i];        if(s == i * (i - 1) / 2)&#123;            if(i - j &lt;= 2)&#123;cout &lt;&lt; n - 1; return 0;&#125;            j = i;        &#125;    &#125;    cout &lt;&lt; n;&#125;</code></pre><h3 id="题H"><a href="#题H" class="headerlink" title="题H"></a>题H</h3><p>题意：由 $n$ 个奶酪，体积分别为 $a_i$，价值为 $b_i$，只能按从前往后的顺序拿，当且仅当第 $i$ 个奶酪被损坏或者拿走才能对第 $i+1$ 奶酪操作。一共由 $m$ 个背包，每个背包体积为 $w_i$，每次拿一个背包从第一个奶酪出发，问最多拿走多少价值的奶酪$(1&lt;=n&lt;=200,1&lt;=m&lt;=1e5,1&lt;=a_i&lt;=200,1&lt;=b_i&lt;=1e5,1&lt;=w_i&lt;=200)$。</p><p>解：我们用 $dp[i][j]$ 表示用到第 $i$ 个背包花费  $j$ 空间的最大价值。因为背包是连续使用的，并且题目给的背包容积是从小到大，所以我们取最大的 $min(n, m)$ 个背包就好。然后我们第一维枚举每一块奶酪，对这么些个背包而言取不取这块奶酪，这里就是 $01$ 背包，判断完之后，更新一下下一位背包，下一个背包如果不取当前奶酪的话，那么 $dp[j + 1][0] = max(dp[j + 1][0], dp[j][k])$, 就可以更新下一个背包不取当前奶酪的情况。最后对第 $dp[m][i]$ 寻找最大价值方案。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 210;int a[N], b[N], w[100010];int dp[N][N];int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n, m, mx = 0; cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i] &gt;&gt; b[i];    for(int i = 1; i &lt;= m; ++ i) cin &gt;&gt; w[i];    if(m &gt; n) &#123;for(int i = 1; i &lt;= n; ++ i) w[i] = w[i + m - n]; m = n;&#125;    for(int i = 1; i &lt;= n; ++ i)&#123;        for(int j = 1; j &lt;= m; ++ j)&#123;            for(int k = w[j]; k &gt;= a[i]; -- k)&#123;                dp[j][k] = max(dp[j][k], dp[j][k - a[i]] + b[i]);            &#125;        &#125;        for(int j = 1; j &lt; m; ++ j)&#123;            for(int k = 0; k &lt;= w[j]; ++ k)&#123;                dp[j + 1][0] = max(dp[j + 1][0], dp[j][k]);            &#125;        &#125;    &#125;        for(auto &amp;x: dp[m]) mx = max(mx, x);    cout &lt;&lt; mx;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至G,D,C,H…&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="动态规划" scheme="https://www.ylq1104.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二分图" scheme="https://www.ylq1104.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营4</title>
    <link href="https://www.ylq1104.cn/posts/31751/"/>
    <id>https://www.ylq1104.cn/posts/31751/</id>
    <published>2023-07-28T11:21:03.000Z</published>
    <updated>2023-07-30T14:48:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>呃呃这场签到一时半会没写出来就去睡觉了，睡醒已经结束，然后一题没开<br>更新至L,F,A,J…<br>(好无聊好无聊好无聊呜呜呜7.30)</p><span id="more"></span><h3 id="题L"><a href="#题L" class="headerlink" title="题L"></a>题L</h3><p>题意：给定一个 $n * m$ 排布的灯，有 $q$ 次操作，每次操作可以  $打开/关闭$ 某具体  $行/列$ , 问最后有多少灯是打开的（$1&lt;=n,m,q&lt;=1e6$）。</p><p>解：由于后面的操作会对当前操作有影响，所以不妨我们对操作倒着看，这时候第一次打开某一行或列必然是增加答案的。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e6 + 10;int row[N], col[N];struct S&#123;    string x1, x2; int x;&#125;s[N];int main()&#123;    int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    ll ans = 0;    for(int i = 1; i &lt;= k; ++ i)&#123;        cin &gt;&gt; s[i].x1 &gt;&gt; s[i].x &gt;&gt; s[i].x2;    &#125;    for(int i = k; i &gt;= 1; -- i)&#123;        auto t = s[i];        if(t.x1 == &quot;row&quot;)&#123;            if(row[t.x] == 0)&#123;                row[t.x] = 1;                if(t.x2 == &quot;on&quot;) ans += m;                n --;            &#125;        &#125;else &#123;            if(col[t.x] == 0)&#123;                col[t.x] = 1;                if(t.x2 == &quot;on&quot;) ans += n;;                m --;            &#125;        &#125;    &#125;    cout &lt;&lt; ans;&#125;</code></pre><h3 id="题F"><a href="#题F" class="headerlink" title="题F"></a>题F</h3><p>题意：$n$ 个候选人每人都有一个 $a_i (political$ $tendencies)$，有 $n - 1$ 轮投票，每轮投票中未出局的候选人可以给一个人投票，票数最多者出局，其中对于 $i$ 这个候选人而言，他会投给  $j$ 候选人，当且仅当存在最大的 $|a_i - a_j|$, 如果同时存在了两个相同最大值的$|a_i - a_j|$ ， 那么优先投给$a_j$ 较大的人。问最后剩下来的是几号候选人。</p><p>解：由题意可得，每轮出局的必然是剩余候选人中 $a_i$ 值是 $最大/最小$， 那么我们可以对 $a_i$ 排完序后对两端用双指针，将两个指针与中间候选人的 $a_{mid}$ 进行比较。 最终复杂度为  $O(n)$</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e6 + 10;pair&lt;int, int&gt; p[N];int main()&#123;    int n; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i)&#123;        int x; cin &gt;&gt; x;        p[i] = &#123;x, i&#125;;    &#125;    sort(p + 1, p + 1 + n);    int l = 1, r = n;    while(l &lt; r)&#123;        int mid = l + r &gt;&gt; 1;        if(2 * p[mid].first &gt; p[l].first + p[r].first)            l ++;        else             r --;    &#125;    cout &lt;&lt; p[l].second;&#125;</code></pre><h3 id="题A"><a href="#题A" class="headerlink" title="题A"></a>题A</h3><p>题意：已知一个消息字符串 $s$, 其加密字符串为 $t+s+t$，其中字符串 $t$ 为识别字符串，用于解码。但对于本题中读取加密字符串是一个个字符读取，当加密字符串 $0101101010$， 已知$t=010$, 其标准的消息字符串 $s=1101$, 但由于读取过程的问题，在计算机读取了加密字符到 $01011010$ 时就会停止并且获得消息字符串 $s=11$ 与需求不符，存在歧义。 题目给定消息字符串 $s$ 的长度和识别字符串 $t$，要求任意构造一个不存在歧义的消息字符串 $s$（$1&lt;=|t|, n&lt;=1000$, 本题中字符串由 $01$ 构成）。</p><p>解：由于可以任意构造且字符串的长度很小，而且我们是知道识别字符串 $t$的， 那么首先要使得 $s$中不存在 $t$，我们可以直接假设 $s$ 全为 $0$， 用 $find$ 函数查看是否存在歧义，存在则用全 $1$ 代替。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;void solve()&#123;    int n, f = 0; string t; cin &gt;&gt; n &gt;&gt; t; string x = t;    for(int i = 1; i &lt;= n; ++ i) x = x + &quot;0&quot;; x = x + t;    if(x.find(t, 1) != x.size() - t.size()) f = 1;    for(int i = 1; i &lt;= n; ++ i) cout &lt;&lt; f; cout &lt;&lt; &#39;\n&#39;;&#125;int main()&#123;    int T; cin &gt;&gt; T;    while(T --) solve();&#125;</code></pre><h3 id="题J"><a href="#题J" class="headerlink" title="题J"></a>题J</h3><p>题意：给定整数 $n$ 和 $m$，要求构造长度为 $n$ 的数组 $a$，其中 $-m&lt;=a_i&lt;=m$, 对任意 $2&lt;=k&lt;=n$，满足连续 $k$ 个元素和 $&gt;=0$，问存在多少种构造情况$(1&lt;=n,m&lt;=5000, 答案模998244252)$</p><p>解：用 $dp[i][j]$ 表示前 $i$ 个元素种包含第 $i$ 个元素最小和为 $j$ 的情况数。我们再用一个 $sum[i][j]$ 表示包含第 $i$ 个元素和为 $j$ 的情况数，这样我们对和从大到小枚举，就 $O(n*m)$ 跑过。</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;const int N = 5010, MOD = 998244353;int dp[N][N + N], sum[N][N + N];int main()&#123;    int n, m; cin &gt;&gt; n &gt;&gt; m;    for(int i = m; i &gt;= -m; -- i) &#123;        sum[1][i + N] = 1;        dp[1][i + N] = dp[1][i + N + 1] + sum[1][i + N];    &#125;    for(int i = 2; i &lt;= n; ++ i)&#123;        for(int j = m; j &gt;= -m; -- j)&#123;            if(j &gt;= 0) sum[i][j + N] = dp[i - 1][j + N - m];            else sum[i][j + N] = dp[i - 1][N - j];            dp[i][j + N] = (dp[i][j + N + 1] + sum[i][j + N]) % MOD;        &#125;    &#125;    cout &lt;&lt; dp[n][N - m];&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;呃呃这场签到一时半会没写出来就去睡觉了，睡醒已经结束，然后一题没开&lt;br&gt;更新至L,F,A,J…&lt;br&gt;(好无聊好无聊好无聊呜呜呜7.30)&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="思维" scheme="https://www.ylq1104.cn/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营3</title>
    <link href="https://www.ylq1104.cn/posts/48710/"/>
    <id>https://www.ylq1104.cn/posts/48710/</id>
    <published>2023-07-27T03:57:51.000Z</published>
    <updated>2023-07-29T04:53:16.486Z</updated>
    
    <content type="html"><![CDATA[<p>更新至A,H,D,J…</p><span id="more"></span><h3 id="题A"><a href="#题A" class="headerlink" title="题A"></a>题A</h3><p>题意：给定二进制数 $x$ 和 $y$，每次操作选择 $x$ 中的一位 $b$, 使得 $x+=b$ 或  $x-=b$，问多少次操作使得 $x=y$。</p><p>解：当 $x=0$ 时怎么操作都不行，反之取 $1$ 操作 $|x-y|$ 次。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;int main()&#123;    string n, m; cin &gt;&gt; n &gt;&gt; m;    ll a = 0, b = 0;    for(int i = 0; i &lt; n.size(); ++ i)        a = a * 2 + (n[i] == &#39;1&#39;);    for(int i = 0; i &lt; m.size(); ++ i)        b = b * 2 + (m[i] == &#39;1&#39;);    if(a == 0 &amp;&amp; b != 0)&#123;cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;; return 0;&#125;    cout &lt;&lt; abs(a - b) &lt;&lt; &#39;\n&#39;;&#125;</code></pre><h3 id="题H"><a href="#题H" class="headerlink" title="题H"></a>题H</h3><p>题意：对一个长度为 $n$ 的数组 $a$， 可以进行无数次操作，每次操作选择 $1&lt;=i,j&lt;=n$，使得 $a_i+=1,a_j-=1$。<br>问能否使得数组 $a$ 都为质数。</p><p>解：这里直接引用哥德巴赫猜想：$任一大于2的偶数都可写成两个质数之和（推至任一大于7的奇数可以写成三个质数之和）$。知道该定理后，我们可以先将 $n - 1$ 个数都变成 $2$，然后判断第 $n$ 个数是不是质数，反之是偶数的话就可以取一个 $2$ 合并后再分解， 是奇数的话看 $n$ 是否大于等于3，再之看 $a_n&gt;=3?$。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;ll a[N];bool ok(ll k)&#123;    for(int i = 2; i * i &lt;= k; ++ i)        if(k % i == 0) return 0;    return 1;&#125;int main()&#123;    int n; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i];    if(n == 1)&#123;        if(ok(a[1]) &amp;&amp; a[1] &gt; 1) cout &lt;&lt; &quot;Yes&quot;;        else cout &lt;&lt; &quot;No&quot;;        return 0;    &#125;    for(int i = 1; i &lt; n; ++ i)&#123;        if(a[i] == 1) a[n] --;        else if(a[i] &gt; 2) a[n] += a[i] - 2;    &#125;        if(a[n] &lt; 2) cout &lt;&lt; &quot;No&quot;;    else if((2 + a[n]) % 2 == 0) cout &lt;&lt; &quot;Yes\n&quot;;     else &#123;        if((n &gt;= 3 &amp;&amp; a[n] &gt;= 3) || ok(a[n])) cout &lt;&lt; &quot;Yes&quot;;        else cout &lt;&lt; &quot;No&quot;;    &#125;&#125;</code></pre><h3 id="题D"><a href="#题D" class="headerlink" title="题D"></a>题D</h3><p>题意：给定一个大小为 $n*n$ 的 $01$ 矩阵，每次操作可以翻转某一具体行或列，最终使得 $min(r_i)&gt;=max(c_j)$，表示每行每列组成的二进制数中，行中最小的二进制数比列中最大的二进制数大。求最少操作次数，不能实现则输出 $-1$。</p><p>解：当且仅当矩阵权威 $0/1$ 的时候满足题目条件。我们可以对全为 $0$ 或 $1$ 的矩阵反推，那么必然存在某一步骤时每行每列要么相等要么就是取一次反，这里我们枚举行。当且仅当 $s[1] == s[i](或s[i]的反， 1 &lt;i&lt;=n)$ 时答案存在。</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;string s[2010];int main()&#123;    int n; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; s[i];    int a = 0, b = 0;    for(int i = 2; i &lt;= n; ++ i)&#123;        if(s[i] == s[1]) continue;        for(int j = 0; j &lt; n; ++ j) s[i][j] = (s[i][j] == &#39;1&#39;) ? &#39;0&#39;: &#39;1&#39;;        if(s[1] == s[i]) a ++;        else &#123;cout &lt;&lt; -1; return 0;&#125;    &#125;    for(int i = 0; i &lt; n; ++ i) if(s[1][i] == &#39;1&#39;) b ++;    cout &lt;&lt; min(min(b, n - b) + a, min(b, n - b) + n - a);&#125;</code></pre><h3 id="题J"><a href="#题J" class="headerlink" title="题J"></a>题J</h3><p>题意：给定 $n$ 个点和 $m$ 对偏序关系 $&lt;u,v&gt;$，构造最少的排列数目 $k$ 使得其中对每个偏序而言至少有一个排列满足的 $u&lt;v$ $(1&lt;=n,m&lt;=1e6)$</p><p>解：当 $k=2$ 时的两个排列为 $1, 2, 3…n-1, n$ 和 $n, n - 1… 3, 2, 1$ 时，对任意一堆偏序必然存在于这二者之一。可见 $k=2$ 是 $k$ 的上限。当 $k=1$ 时仅存在一个排列满足所有的偏序，显然我们可以把所有偏序跑一遍拓扑，如果拓扑存在则 $k=1$。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;vector&lt;int&gt; g[N];int d[N], q[N];int main()&#123;    int n, m, t = 0; cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= m; ++ i)&#123;        int u, v; cin &gt;&gt; u &gt;&gt; v;        g[u].push_back(v); d[v] ++;    &#125;    for(int i = 1; i &lt;= n; ++ i) if(d[i] == 0) q[++ t] = i;    for(int i = 1; i &lt;= t; ++ i)&#123;        for(auto &amp;x: g[q[i]])&#123;            if(-- d[x] == 0) q[++ t] = x;        &#125;    &#125;    if(t == n)&#123;        cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;        for(int i = 1; i &lt;= n; ++ i) cout &lt;&lt; q[i] &lt;&lt; &#39; &#39;;    &#125;else &#123;        cout &lt;&lt; 2 &lt;&lt; &#39;\n&#39;;        for(int i = 1; i &lt;= n; ++ i) cout &lt;&lt; i &lt;&lt; &#39; &#39;;        cout &lt;&lt; &#39;\n&#39;;        for(int i = n; i &gt;= 1; -- i) cout &lt;&lt; i &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至A,H,D,J…&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数学" scheme="https://www.ylq1104.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营2</title>
    <link href="https://www.ylq1104.cn/posts/32391/"/>
    <id>https://www.ylq1104.cn/posts/32391/</id>
    <published>2023-07-26T15:47:35.000Z</published>
    <updated>2023-07-28T11:24:07.365Z</updated>
    
    <content type="html"><![CDATA[<p>更新至E,I,K,F,D…</p><span id="more"></span><h3 id="题E"><a href="#题E" class="headerlink" title="题E"></a>题E</h3><p>题意：题目给定一个 $x$, 要求我们找出一个 $y$ 要求满足 $\frac{y^2}{10^k} = x$， 其中 $k$ 可以为任意数，例如 $y = 123, x = 1512$, (其中 $\frac{y^2}{10^k} = \frac{15129}{10^1}=1512= x$。其中 $1&lt;=x,y&lt;=1e9$)。</p><p>解：由于要求 $y^2$ 的前几位数有 $x$， 那么显然我们可以对 $x$ 后面加若干个 $0$，使得其 $sqrt()$ 满足 $y$ 的平方并逼近答案。枚举加 $0$  的个数即可。<br>(tips :  这里注意 $sqrt()$ 的精度问题， 需要同时判断 $sqrt()$ 和 $sqrt() + 1$, 我多加了个$sqrt() - 1$ 就一直wawawa。)</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define PII pair&lt;int, int&gt;#define int long long#define ll long longusing namespace std;const int N = 2e5 + 10, MOD = 1e9 + 7;string get(ll x)&#123;    string s = &quot;&quot;;    while(x)&#123;        char c = x % 10 + &#39;0&#39;;        s = c + s;        x /= 10;    &#125;    return s;&#125;bool ok(int k, int n)&#123;    string s = get(k * k);    int ans = 0;    string ss = get(n); int len = ss.size();    for(int i = 0; i &lt; len; ++ i)&#123;        ans = ans * 10 + (s[i] - &#39;0&#39;);    &#125;    if(ans == n) return 1;    return 0;&#125;void solve()&#123;    ll n; cin &gt;&gt; n;    ll m = n;    while(n &lt;= 1e18)&#123;        ll k = sqrt(n);        if(ok(k, m)) &#123;cout &lt;&lt; k &lt;&lt; &#39;\n&#39;; return ;&#125;        if(ok(k + 1, m)) &#123;cout &lt;&lt; k + 1&lt;&lt; &#39;\n&#39;; return ;&#125;        n *= 10;    &#125;    cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;&#125;signed main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre><h3 id="题I"><a href="#题I" class="headerlink" title="题I"></a>题I</h3><p>题意：两人轮流玩棋盘大小为 $n * m$ 的五子棋，要求构造一个平局的情况，其中先手为 $’x’$, 另一个人为 $’o’$ ，（$1 &lt;= n, m &lt;= 1000$）。</p><p>解：首先可以构造这样的局面</p><pre><code>xoxoxoxoxo...oxoxoxoxox...xoxoxoxoxo...oxoxoxoxox...xoxoxoxoxo...oxoxoxoxox...</code></pre><p>此时只会出现斜对角五着连线， 这时将每三行的二三行对换，形成如下局面</p><pre><code>xoxoxoxoxo...xoxoxoxoxo...oxoxoxoxox...oxoxoxoxox...oxoxoxoxox...xoxoxoxoxo...</code></pre><p>这时候如果我们直接输出 $n * m$, $’x’$ 和 $’o’$ 的差值会有 $0$、$1$ 和 $2$ 两种情况， 由于 $’x’$ 是先手，所以多一个无妨，除此以外，对于其他不相等的情况修改一步棋即可。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define all(x) x.begin(),x.end()#define pb(x) push_back(x)#define PII pair&lt;int, int&gt;#define ll long longusing namespace std;const int N = 2e3 + 10;char s[N][N];void solve()&#123;    int n, m; cin &gt;&gt; n &gt;&gt; m;    int a = 0, b = 0;    for(int i = 1; i &lt;= n; ++ i)&#123;        for(int j = 1; j &lt;= m; ++ j)&#123;            if(s[i][j] == &#39;x&#39;) a ++;            else b ++;        &#125;    &#125;    if(b &gt; a) s[3][1] = &#39;x&#39;;    else if(a &gt; b + 1) s[1][1] = &#39;o&#39;;    for(int i = 1; i &lt;= n; ++ i)&#123;        for(int j = 1; j &lt;= m; ++ j)&#123;            cout &lt;&lt; s[i][j];        &#125;        cout &lt;&lt; &#39;\n&#39;;    &#125;    if(b &gt; a) s[3][1] = &#39;o&#39;;    else if(a &gt; b + 1) s[1][1] = &#39;x&#39;;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    for(int i = 1; i &lt;= N - 10; ++ i)&#123;        for(int j = 1; j &lt;= N - 10; ++ j)&#123;            if((i + j) &amp; 1) s[i][j] = &#39;o&#39;;            else s[i][j] = &#39;x&#39;;        &#125;    &#125;    for(int i = 3; i &lt;= N - 10; i += 3) swap(s[i], s[i - 1]);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre><h3 id="题K"><a href="#题K" class="headerlink" title="题K"></a>题K</h3><p>题意：有长度 $n$ 的数组  $a$ 和  $b$, 其中 $a_i$ 表示一个盒子里的分数，  $b_i$ 表示盒子有没有盖子，这里 $b_i$用 $0$ 和  $1$ 表示有没有盖子。 对于每一个盖子，我们可以将其左移或右移一个单位，也可以不移动。求我们可以获得的最大分数是多少（$0 &lt;= a_i 1e9$ , $0 &lt;= b_i &lt;= 1$）。</p><p>解：我们用 $dp[i][1/2/3]$ 分别表示前 $i$ 个 $box$ 及当前盖子的 $左移/不动/右移$ 三种状态。</p><p>可以理解当前 $i$ 位置有盖子时，如果我们将其左移，那么左边那个位置原本就是没有盖子的，也就是对前面的 $dp[i - 1][1]$ 进行状态转移$dp[i][1] = dp[i - 1][1] + a[i - 1];$ ，另外两种状态依此类推。<br>当此位置没有盖子时，我们考虑将空盖子左移时是对前一个没有影响的情况，即 $dp[i - 1][1]$ 和 $dp[i - 1][2]$； 当前盖子不动时则是对前一状态的三种状态进行转移。</p><p>代码如下</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 1 &lt;&lt; 30const int N = 1e6 + 10;int a[N], b[N];ll dp[N][4];int main()&#123;    int n; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i];    for(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; b[i];    for(int i = 1; i &lt;= n; ++ i)&#123;        if(b[i])&#123;            dp[i][1] = dp[i - 1][1] + a[i - 1];            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + a[i];            dp[i][3] = max(&#123;dp[i - 1][1], dp[i - 1][2], dp[i - 1][3]&#125;) + a[i + 1];        &#125;else &#123;            dp[i][1] = max(dp[i - 1][1], dp[i - 1][2]);            dp[i][2] = max(&#123;dp[i - 1][1], dp[i - 1][2], dp[i - 1][3]&#125;);        &#125;    &#125;    cout &lt;&lt; max(&#123;dp[n][1], dp[n][2], dp[n][3]&#125;);&#125;</code></pre><p>(擦擦擦擦，我开始将连续盖子分块，然后取最小的$1/2/3$个罐子扔了，然后模拟了两个小时还是通过$0.27$，心态整崩了、、、)</p><h3 id="题F"><a href="#题F" class="headerlink" title="题F"></a>题F</h3><p>题意：给定一个 $n$，表示有一个长度为 $n$ 的链，其中结点下标为 $1&lt;=i&lt;=n$，且每个相邻的结点差值为 $1$，题目给定 $R、G、B$ 三种颜色的初始位置下标， $A$ 和 $B$ 二人轮流操作，每次移动一个颜色到一个相邻的结点，当一个人移动后三种颜色的坐标 $(R,G,B)$ 重复出现时 $lose$。</p><p>解：因为每次操作仅能使得一个颜色的 $+1$ 或  $-1$， 我们可以构造一个边长为 $n$ 的正方体，当且仅当棋子走到走过的位置点时 $lose$，这里联系到二分图博弈模型：当且仅当起始点位于最大匹配上时先手必胜。<br>当 $n$ 为偶数时，任何起始点开始走完所有点时都是先手必胜。<br>当 $n$ 为奇数时，当 $(R,G,B)$ 三点坐标和为奇数时，无法走完全部的点，此时先手必败。 反之坐标和为偶数时能在奇数步内走完全部点， 先手必胜。</p><pre><code class="cpp">#include&lt;iostream&gt;using namespace std;int main()&#123;    int T; cin &gt;&gt; T;    while(T --)&#123;        int n, a, b, c; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;        if(n &amp; 1)&#123;            if((a + b + c) &amp; 1) cout &lt;&lt; &quot;Bob\n&quot;;            else cout &lt;&lt; &quot;Alice\n&quot;;        &#125;else cout &lt;&lt; &quot;Alice\n&quot;;    &#125;&#125;</code></pre><h3 id="题D"><a href="#题D" class="headerlink" title="题D"></a>题D</h3><p>题意：共有 $n$ 个人，$m$ 道菜，$n$ 个人要轮流共点 $k$ 道菜。每个人对每道菜的满意度不同，给定 $n*m$ 个满意度，如何选菜使得总满意度最大<br>（$1&lt;=n&lt;=2000$,$1&lt;=k&lt;=m&lt;=2000$,$1&lt;=A_{i,j}(满意度)&lt;=1e9$，每个菜最多点一次，升序输出答案）。</p><p>解：如果从前往后贪心，对当前的人来说后面的人可能选择自己最喜欢的菜，所以他应该选择后面的人没选过的菜中自己最喜欢的。因此我们倒着选菜，每个人选择自己最喜欢的菜，这样对于正序的某个人 $i$ 来说，自己应该选择除去 $k-(i+1)$ 个菜之后自己最喜欢的菜，$n,m$ 的范围不超过 $2000$, $O(n * m)$ 暴力即可。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 1 &lt;&lt; 30const int N = 2e3 + 10;int a[N][N], st[N];void solve()&#123;    int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i = 1; i &lt;= n; ++ i)&#123;        for(int j = 1; j &lt;= m; ++ j)&#123;            cin &gt;&gt; a[i][j];        &#125;    &#125;    for(int i = 1; i &lt;= m; ++ i) st[i] = 0;    vector&lt;int&gt; ans;    for(int i = k - 1; i &gt;= 0; -- i)&#123;        int x = i % n + 1, k = -1;        for(int j = 1; j &lt;= m; ++ j)&#123;            if(st[j]) continue;            if(k == -1 || a[x][j] &gt; a[x][k]) k = j;        &#125;        st[k] = 1; ans.push_back(k);    &#125;    sort(ans.begin(), ans.end());    for(auto i: ans) cout &lt;&lt; i &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;&#125;int main()&#123;    int T; cin &gt;&gt; T;    while(T --) solve();&#125;</code></pre><h3 id="题G"><a href="#题G" class="headerlink" title="题G"></a>题G</h3><p>题意：给定一个字符串 $s$， 判断其是否为对称字符串 $S$， 其中 $S$ 的定义如下</p><pre><code>1、S是空字符串。2、S由&#39;o&#39;,&#39;s&#39;,&#39;x&#39;,&#39;z&#39;等若干个组成。3、S由若干个形如bSq,dSp,qSb,nSu,uSn,oSo...组成</code></pre><p>若干个 $S$ 直接拼接在一起也为 $S$。</p><p>解：马拉车，会了再写。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新至E,I,K,F,D…&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="动态规划" scheme="https://www.ylq1104.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Nim游戏" scheme="https://www.ylq1104.cn/tags/Nim%E6%B8%B8%E6%88%8F/"/>
    
    <category term="马拉车" scheme="https://www.ylq1104.cn/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>牛客暑期多校训练营1</title>
    <link href="https://www.ylq1104.cn/posts/32711/"/>
    <id>https://www.ylq1104.cn/posts/32711/</id>
    <published>2023-07-25T08:01:43.000Z</published>
    <updated>2023-07-28T11:25:05.481Z</updated>
    
    <content type="html"><![CDATA[<p>摆了好久，开始准备自己的棺材本<br>更新至D,J,K…</p><span id="more"></span><h3 id="题D"><a href="#题D" class="headerlink" title="题D"></a>题D</h3><p>题意：在一个 $n*m$ 且布满巧克力的二维平面上, $A 和 B$ 两个人轮流操作，每次操作选择一个坐$（x, y）$,这时他能将 $(1&lt;=i&lt;=x,1&lt;=j&lt;=y)$ 上的巧克力都吃了，每个人操作时至少吃一个巧克力，谁吃最后一个巧克力则输。</p><p>解：当且仅当 $（n == m || n == 1）$ 时$K$吃最后一块。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;#define A puts(&quot;Walk Alone&quot;)#define K puts(&quot;Kelin&quot;)int main()&#123;    int n, m; cin &gt;&gt; n &gt;&gt; m;    if(n == m &amp;&amp; n == 1) A;    else K;&#125;</code></pre><h3 id="题J"><a href="#题J" class="headerlink" title="题J"></a>题J</h3><p>题意：$A$ 初始有 $n$ 元，他每次 gamble 花费 $x$ 元赌注，有 $0.5$ 概率获胜，获胜则获得 $2 * x$ 元， 反之无收获，问 $A$ 赚取 $m$ 元的概率是多少。其中 $x$ 初始值为 $1$, 若上一轮获胜则 $x = 1$， 反之 $x = x * 2$, 对于概率 $a = x / y$ 满足 $a * y = x$ $MOD$ $998244353$ ($1&lt;=n,m&lt;=1e9$)</p><p>解：由题意得，倘若我们连续输了$i$轮，那么第$i+1$轮获胜的话就可以获得$1$元。对于 $x$ 元钱，最多只能输 $lg = log2(x + 1)$ 次， 此时无法进行下一轮。此时我们必输的概率 $p = \frac{1}{2^{lg}}$, 那么获胜的能获胜的概率即为 $1 - p$。同时我们发现，对于$（1, 2)$、$(3，4，5，6)$、$（7，8，9，10，11，12，13，14）$ ，这一些区间里，必输的场次是一样的，那么对于一个区间内相同的 $p$, 我们可以使得$ans *= pow(p, 场次数)$，这里我们用$mx$计算出每个区间的上限，从而得出场次数，由此解得。</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10, MOD = 998244353;ll qmi(ll a, ll b)&#123;    ll ans = 1;    while(b)&#123;        if(b &amp; 1) ans = ans * a % MOD;        a = a * a % MOD;        b &gt;&gt;= 1;    &#125;    return ans;&#125;int main()&#123;    ll n, m, ans = 1, sum = 0, x = 0, mx; cin &gt;&gt; n &gt;&gt; m;    for(ll x = n; x &lt; m + n; x = mx)&#123;        ll lg = log2(x + 1);        ll p = (1 - qmi(qmi(2, lg), MOD - 2) + MOD) % MOD;        mx = min((1ll &lt;&lt; (lg + 1)) - 1, m + n);        ans = ans * qmi(p, mx - x) % MOD;    &#125;    cout &lt;&lt; ans;&#125;</code></pre><h3 id="题K"><a href="#题K" class="headerlink" title="题K"></a>题K</h3><p>题意：给定一个无向图和整数 $k$，同时可以在两个已连的点间增加一点，操作次数不限。问距离$1$结点距离不超过$K$的最大点数为多少。<br>解：由以下数据得出无向图。</p><pre><code>8 9 31 21 31 53 43 64 55 66 77 8</code></pre><p><img src="/picture/nk11.png" class="lazyload placeholder" data-srcset="/picture/nk11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>其中我们可以将其处理为一颗拓扑型的树，得出每个结点到结点 $1$ 的最短距离，如下图所示。<br><img src="/picture/nk12.png" class="lazyload placeholder" data-srcset="/picture/nk12.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>然后对于那些多余的边，就可以对答案 $ans += k - dist[u]$, 同时对于如该样例的单条叶子结点 $2$ 而言，其对答案的贡献为 $k - dist[2]$。最终得到如下的图，图中除结点 $8$ 以外到结点 $1$ 的距离都 $&lt;=k$。<br><img src="/picture/nk13.png" class="lazyload placeholder" data-srcset="/picture/nk13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>代码如下</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;vector&lt;int&gt; g[N];int dist[N], pre[N];int main()&#123;    int n, m, k; ll ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i = 1; i &lt;= n; ++ i) dist[i] = -1;    for(int i = 1; i &lt;= m; ++ i)&#123;        int u, v; cin &gt;&gt; u &gt;&gt; v;        g[u].push_back(v);        g[v].push_back(u);    &#125;    queue&lt;int&gt; q;    dist[1] = 0;    q.push(1);    while(q.size())&#123;        int u = q.front(); q.pop();        //if(dist[u] == -1) continue;        if(dist[u] &lt;= k) ans ++;        for(auto &amp;v: g[u])&#123;            if(dist[v] == -1)&#123;                dist[v] = dist[u] + 1;                pre[v] = u;                q.push(v);            &#125;else if(pre[u] != v) ans += max(k - dist[u], 0);        &#125;    &#125;    for(int i = 2; i &lt;= n; ++ i)&#123;        if(dist[i] != -1 &amp;&amp; g[i].size() == 1) ans += max(k - dist[i], 0);    &#125;    cout &lt;&lt; ans;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;摆了好久，开始准备自己的棺材本&lt;br&gt;更新至D,J,K…&lt;/p&gt;</summary>
    
    
    
    <category term="思维" scheme="https://www.ylq1104.cn/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="模拟" scheme="https://www.ylq1104.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数学" scheme="https://www.ylq1104.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换</title>
    <link href="https://www.ylq1104.cn/posts/26046/"/>
    <id>https://www.ylq1104.cn/posts/26046/</id>
    <published>2023-05-04T16:15:23.000Z</published>
    <updated>2023-05-04T16:38:34.443Z</updated>
    
    <content type="html"><![CDATA[<p>蒻苟学信号</p><span id="more"></span><h2 id="时域到频域的转变"><a href="#时域到频域的转变" class="headerlink" title="时域到频域的转变"></a>时域到频域的转变</h2><p>对于一个关于时间的二维函数我们易懂，这也就是所谓的时域函数<br>而频域就是将一个周期内的时域信号根据其频率和振幅大小转换为另一个函数<br>以下图为例，对于一个周期为$T_1$，振幅为$A_1$的正弦函数，我们将其转化在频域函数图上是这样的。<br><img src="/picture/FT1.png" class="lazyload placeholder" data-srcset="/picture/FT1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>我们再增加一个周期为$T_2$，振幅为$A_2$的周期函数，其对应的频域如此<br><img src="/picture/FT2.png" class="lazyload placeholder" data-srcset="/picture/FT2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="任何周期信号都能够由不同谐波的正弦波叠加而成，这由傅里叶发现，因此称之为傅里叶级数"><a href="#任何周期信号都能够由不同谐波的正弦波叠加而成，这由傅里叶发现，因此称之为傅里叶级数" class="headerlink" title="任何周期信号都能够由不同谐波的正弦波叠加而成，这由傅里叶发现，因此称之为傅里叶级数"></a>任何周期信号都能够由不同谐波的正弦波叠加而成，这由傅里叶发现，因此称之为傅里叶级数</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;蒻苟学信号&lt;/p&gt;</summary>
    
    
    
    <category term="信号与线性系统" scheme="https://www.ylq1104.cn/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="时域——频域" scheme="https://www.ylq1104.cn/tags/%E6%97%B6%E5%9F%9F%E2%80%94%E2%80%94%E9%A2%91%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>割点</title>
    <link href="https://www.ylq1104.cn/posts/47101/"/>
    <id>https://www.ylq1104.cn/posts/47101/</id>
    <published>2023-04-29T17:05:06.000Z</published>
    <updated>2024-05-07T08:22:04.469Z</updated>
    
    <content type="html"><![CDATA[<p>$Y_{lq}$</p><span id="more"></span><p><a href="https://www.luogu.com.cn/problem/P3388">洛谷割点模板</a></p><p>何为割点？<br>简单来说是在一个无向图中，若删除该点，则该无向图将会被分为两部分<br><img src="/picture/tarjan1.png" class="lazyload placeholder" data-srcset="/picture/tarjan1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>如上图所示，结点$D$是一个割点，但是$A、B、C、E、F$不是割点</p><p>此外在这里我们引入$dfn[i],low[i]$ 两个概念<br>$dfn[i]:遍历到该结点$$i$$时的时间，称之为——时间戳$<br>$low[i]:不通过父结点$$i$$所能到达的最小的时间戳的值，即最小回溯值$<br>例如对上图我们从$A$结点开始遍历，标记时间戳是这样的<br><img src="/picture/tarjan2.png" class="lazyload placeholder" data-srcset="/picture/tarjan2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>再之，我们求得每个结点的$low$值如下<br><img src="/picture/tarjan3.png" class="lazyload placeholder" data-srcset="/picture/tarjan3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>我们可以发现，对结点$E、F$而言，他们无法回溯到比自己更小的$dfn$值，即显然他们的父节点$D$为一个割点。<br>我们用$O(n)$的复杂度遍历图中的每一个结点，并对其的$dfn、low、st$进行初始化</p><pre><code class="cpp">    st[u] = 1;    dfn[u] = low[u] = ++ in;    //我们以一个全局变量in来表示记录到该节点的时间</code></pre><p>结点为割点的两种情况：<br>1、当前结点$u$为根结点，且存在两个以上的子结点<br>2、当前结点$u$不为根节点，且对于其连接的子结点$v$而言，$low[v]&gt;=dfn[u]$，说明其儿子$v$无法通过其他结点跑到$u$结点之前<br>因此，当我们遍历发现该结点为标记过时</p><pre><code class="cpp">    if(!st[v])&#123;        num ++; //累计结点u的子结点数量        tarjan(v, u); //遍历v结点出发的图        low[u] = min(low[u], low[v]); //更新low[u]        if(fa != u &amp;&amp; low[v] &gt;= dfn[u] &amp;&amp; !ok[u])&#123;  //倘若该节点不是根节点，且满足割点条件            ok[u] = 1;            ans ++;        &#125;    &#125;</code></pre><p>反之该结点标记过了，并且结点没有往回跑的话，我们如果继续用$low[u]=min(low[u],low[v])$的话，<br>以下图为例，<br><img src="/picture/tarjan4.png" class="lazyload placeholder" data-srcset="/picture/tarjan4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>当我们在从$D$跑到$E$时，如果对$E$用$low[E]=min(low[E],low[C])$的话，那么$low[E]=low[C]=1$，此时不满足显然的割点条件，因此<br>我们需要对标记过的连接值取$low[u]=min(low[u],dfn[v])$<br>至此我们得出该题的解决方案.</p><details><summary>代码</summary><pre><code>#include "bits/stdc++.h"#define rep(i, n, m) for(int i = n; i <= m; ++i)using namespace std;const int N = 8e5 + 10;int dfn[N], low[N], st[N], ok[N], in = 0;int h[N], ne[N], e[N], cnt, ans = 0;void add(int a, int b)&#123;     e[cnt] = b, ne[cnt] = h[a], h[a] = cnt++;&#125;void tarjan(int u, int fa)&#123;    st[u] = 1;    dfn[u] = low[u] = ++ in;    int num = 0;    for(int i = h[u]; ~i; i = ne[i])&#123;        int v = e[i];        if(!st[v])&#123;            num ++;            tarjan(v, u);            low[u] = min(low[u], low[v]);            if(fa != u && low[v] >= dfn[u] && !ok[u])&#123;                ok[u] = 1;                ans ++;            &#125;        &#125;else if(v != fa)&#123;            low[u] = min(low[u], dfn[v]);        &#125;    &#125;    if(u == fa && num >= 2 && !ok[u])&#123;        ok[u] = 1;        ans ++;    &#125;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    memset(h, -1, sizeof h);    memset(ok, 0, sizeof ok);    int n, m; cin >> n >> m;    rep(i, 1, m)&#123;        int u, v; cin >> u >> v;        add(u, v), add(v, u);    &#125;    rep(i, 1, n)&#123;        if(!st[i])&#123;            in = 0;            tarjan(i, i);        &#125;    &#125;    cout << ans << '\n';    rep(i, 1, n)&#123;        if(ok[i]) cout << i << ' ';    &#125;    return 0;&#125;</code></pre></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;$Y_{lq}$&lt;/p&gt;</summary>
    
    
    
    <category term="图论" scheme="https://www.ylq1104.cn/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="Tarjan" scheme="https://www.ylq1104.cn/tags/Tarjan/"/>
    
    <category term="割点" scheme="https://www.ylq1104.cn/tags/%E5%89%B2%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>烂题三道</title>
    <link href="https://www.ylq1104.cn/posts/8176/"/>
    <id>https://www.ylq1104.cn/posts/8176/</id>
    <published>2023-03-28T14:01:50.000Z</published>
    <updated>2023-04-30T10:41:10.295Z</updated>
    
    <content type="html"><![CDATA[<p>算是最近做的几道题里觉得值得回顾一下的吧</p><span id="more"></span><p><a href="https://atcoder.jp/contests/abc295/tasks/abc295_d">ABC295_D</a><br>题意：给定一个由0~9组成的字符串S, 且$|S| &lt;= 5e5$，求存在多少个$l,r$满足$S_l,…S_r$中满足每个数字出现偶数次个</p><p>思路：假设我们只考虑 $l$ 到 $r$ 中的一种数字，如果我们求该数字的个数前缀和，如果满足题意的话那么 $sum[r] - sum[l - 1] = 0 (mod 0) $，那么显然这俩个的奇偶性是相同的。<br>那么我们可以用map来从前往后记录每种出现的状态的个数，用pre[i][j]来记录数字i到j位置出现的个数。<br>长度为10的状态st表示每一个数字出现个数的奇偶性</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define rep(i, n, m) for(int i = n; i &lt;= m; ++i)#define per(i, n, m) for(int i = n; i &gt;= m; --i)#define ll long longusing namespace std;const int N = 5e5 + 10;string st;int pre[10][N];ll ans;map&lt;string, int&gt; p;void cal(int u)&#123;    rep(i, 0, 9) st[i] = pre[i][u] % 2 + &#39;0&#39;;    //更新当前每个状态出现个数的奇偶性    if(p.count(st))ans += 1ll * p[st];    p[st] ++;&#125;int main()&#123;    string s; cin &gt;&gt; s;    int n = s.size(); s = &#39; &#39; + s;    st.resize(10); //初始化状态st    rep(i, 0, 9) st[i] = &#39;0&#39;;    p[st] ++;     rep(i, 1, n)&#123;        rep(j, 0, 9)&#123;            pre[j][i] = pre[j][i - 1] + (j == s[i] - &#39;0&#39;);        &#125;        cal(i);    &#125;    cout &lt;&lt; ans;    return 0;&#125;</code></pre><p><a href="https://atcoder.jp/contests/abc295/tasks/abc295_e">ABC295_E</a><br>题意：给定 $n, m, k$,<br>和一个长度为 $n$ 的数组，为$A_1,A_2…A_n$ ,<br>其中$1&lt;=k&lt;=n&lt;=2000, 1&lt;=m&lt;=2000, 0&lt;=A_i&lt;=m$<br>我们可以选择其中为0的位置，其值随机为 $1到m$ 的一个值，然后求对该数组排序后$A_k$的期望值</p><p>思路：据我们所知期望值$E(x)=∑i*p_{x=i} =∑ p_{x&gt;=i} $，那么对于本题，对于每个$i∈(1,m)$,我们求排序后k位置上的$A_k &gt;= i$的概率对答案的贡献</p><p>其中，我们统计原数组中比i大的数字个数tar和等于0的个数ze，我们若要第k位大于等于i，则还需要$n-k+1-tar$ 个大于等于i的数，如果我们定义此时的$tar=n-k+1-tar$，则当tar小于0时，无论怎么操作都能满足要求，此时对答案的贡献为1.<br>假设我们需要的$tar-ze&gt;0$时，说明没有足够的0来满足题目要求，所以此时对答案的贡献都是0<br>倘若以上情况都不是，我们的贡献为$C_{ze}^jp^j(1-p)^{ze-j}$,其中p为选中的都是大于i的情况，即$p=(m-i+1)/m$<br>因为这题的数值都很小，可以用地推求组合数的方法写</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define rep(i, n, m) for(int i = n; i &lt;= m; ++i)#define int long longusing namespace std;const int N = 2e3 + 10, MOD = 998244353;int a[N], C[N][N];int qmi(int a, int b)&#123;    int ans = 1;    while(b)&#123;        if(b &amp; 1) ans = ans * a % MOD;        a = a * a % MOD;        b &gt;&gt;= 1;    &#125;    return ans % MOD;&#125;signed main()&#123;    //求组合数    rep(i, 0, N - 1)&#123;        rep(j, 0, i)&#123;            if(j == 0) C[i][j] = 1;            else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;        &#125;    &#125;    int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    rep(i, 1, n) cin &gt;&gt; a[i];    int ans = 0;    rep(i, 1, m)&#123;        int tar = n - k + 1, ze = 0;        rep(j, 1, n)&#123;            if(a[j] &gt;= i) tar --;            else if(a[j] == 0) ze ++ ;        &#125;        if(tar &lt; 0 || tar - ze &gt; 0)&#123;            // 如果满条件            if(tar &lt; 0) ans ++;            continue;        &#125;        int p = (m - i + 1) * qmi(m, MOD - 2) % MOD;        // pp = 1 - p        int pp = ((1 - p) % MOD + MOD) % MOD;        //此时必须需要选择的 0 的个数为 tar ~ ze        rep(j, tar, ze)&#123;            int x = qmi(p, j), y = qmi(pp, ze - j);            int num = C[ze][j] % MOD * x % MOD * y % MOD;            ans = (ans + num) % MOD;        &#125;    &#125;    cout &lt;&lt; ans;&#125;</code></pre><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2586">How far away</a><br>一道LCA题，算板子吧</p><p>题意：给定T组数据，每组数据有一棵树，给定$n,m$，分别为点数和边数，然后$n-1$行输入两个点及其边长，然后m组询问，每次查询两个结点的最近公共祖先</p><p>思路：我们利用倍增的思想，用 $f[i][j]$ 记录$i$结点往上$(1 &lt;&lt; j)$ 的祖先，用 $dist[i] $记录$i$到根节点的深度,同时用一个$cost[i][j]$同样用倍增的思路记录路径长度<br>其中我们用</p><pre><code>       for(int i  = 1; i &lt;= n; ++ i)&#123;        lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);    &#125;</code></pre><p>来地推$lg[i]$</p><pre><code class="cpp">#include &lt;iostream&gt;#define rep(i, n, m) for(int i = n; i &lt;= m; ++i)#define per(i, n, m) for(int i = n; i &gt;= m; --i)using namespace std;const int N = 8e5 + 10;int w[N], h[N], ne[N], e[N], cnt, lg[N], dist[N], f[N][30], cost[N][30];void add(int a, int b, int c)&#123;     e[cnt] = b, w[cnt] = c, ne[cnt] = h[a], h[a] = cnt++;&#125;void dfs(int u, int fa)&#123;    dist[u] = dist[fa] + 1; //u的深度+1    f[u][0] = fa; //u的上一个祖先时fa    for(int i = 1; i &lt;= lg[dist[u]]; ++ i)&#123;        //倍增更新祖先和路径长度        f[u][i] = f[f[u][i - 1]][i - 1];        cost[u][i] = cost[f[u][i - 1]][i - 1] + cost[u][i - 1];    &#125;    for(int i = h[u]; ~i; i = ne[i])&#123;        int j = e[i];        if(j != fa)&#123;            //更新上一层路径            cost[j][0] = w[i];            dfs(j, u);        &#125;    &#125;&#125;int LCA(int a, int b)&#123;    int ans = 0;    //我们默认使得a的深度大于等于b的深度    if(dist[a] &lt; dist[b]) swap(a, b);    //我们将a上升到与b同一深度的位置，同时给ans增加贡献    while(dist[a] &gt; dist[b])         ans += cost[a][lg[dist[a] - dist[b]] - 1],        a = f[a][lg[dist[a] - dist[b]] - 1];    if(a == b) return ans;    //二者仍然不相等，将a和b同时上升到公共祖先的儿子    for(int i = lg[dist[a]] - 1; i &gt;= 0; --i)&#123;        if(f[a][i] != f[b][i])&#123;            ans += cost[a][i];            ans += cost[b][i];            a = f[a][i], b = f[b][i];        &#125;    &#125;    return ans + cost[a][0] + cost[b][0];&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int T; cin &gt;&gt; T;    while(T--)&#123;           memset(h, -1, sizeof h);        int n, m, s; cin &gt;&gt; n &gt;&gt; m;            for(int i  = 1; i &lt;= n; ++ i)&#123;            lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);        &#125;        rep(i, 1, n - 1)&#123;            int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;               add(a, b, c); add(b, a, c);        &#125;           dfs(1, 0); //我们默认以1为根节点深搜        while(m --)&#123;            int a, b; cin &gt;&gt; a &gt;&gt; b;            cout &lt;&lt; LCA(a, b) &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;算是最近做的几道题里觉得值得回顾一下的吧&lt;/p&gt;</summary>
    
    
    
    <category term="杂题" scheme="https://www.ylq1104.cn/categories/%E6%9D%82%E9%A2%98/"/>
    
    
    <category term="组合数" scheme="https://www.ylq1104.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
    <category term="二进制" scheme="https://www.ylq1104.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="LCA" scheme="https://www.ylq1104.cn/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>字典树板子</title>
    <link href="https://www.ylq1104.cn/posts/57640/"/>
    <id>https://www.ylq1104.cn/posts/57640/</id>
    <published>2023-03-02T12:15:39.000Z</published>
    <updated>2023-03-02T12:38:40.440Z</updated>
    
    <content type="html"><![CDATA[<p>做道板子</p><span id="more"></span><p>洛谷题 ：<a href="https://www.luogu.com.cn/problem/P8306">字典树</a></p><p>我们考虑将一组字符串转化为树的形式</p><p><img src="/picture/trie1.jpg" class="lazyload placeholder" data-srcset="/picture/trie1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>我们使得每个结点之间连接的边表示一个字符，那么对于一个结点，它可以连接有限个结点（假设字符只有a-z，那么一个结点最多连接26个亲儿子），</p><p>于是我们以图示为例子，以“cd”结尾的字符串有两个，分别为 “cdf” 和 “cdh”， 所以我们可以在初始化的时候更新trie数组，</p><p>我们用trie[p][x] 数组表示p结点连接的字符x是否存在，那么我们可以用Ascall来替代字符的数字，因为本题的字符有数字有字母，所以我们以ascall值最小的0来做基底</p><p>以cnt来表示结点编号</p><pre><code class="cpp">void in(string s)&#123;    int p = 0, n = s.size();    rep(i, 0, n - 1)&#123;        int x = s[i] - &#39;0&#39;;        if(!trie[p][x]) trie[p][x] = ++ cnt; // 如果该节点没有连接s[i]，那么新增结点编号        p = trie[p][x]; // 下传结点        ans[p] ++; //以该结点结尾的字符串个数    &#125;&#125;</code></pre><p>于是我们便可以便捷地查询有s前缀字符串的个数</p><pre><code class="cpp">int get(string s)&#123;    int p = 0, n = s.size();    rep(i, 0, n - 1)&#123;        int x = s[i] - &#39;0&#39;;        if(!trie[p][x]) return 0; //还没找完就没有了，直接 return 0        p = trie[p][x];    &#125;    return ans[p]; //&#125;</code></pre><p>注意trie数组的大小，因为 本题一次性预处理的字符串个数有 1e5， 所以在累加结点编号的时候难免会超出 很多</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define rep(i, n, m) for(int i = n; i &lt;= m; ++i)using namespace std;const int N = 3e6 + 10;int ans[N], trie[N][150], cnt;void in(string s)&#123;    int p = 0, n = s.size();    rep(i, 0, n - 1)&#123;        int x = s[i] - &#39;0&#39;;        if(!trie[p][x]) trie[p][x] = ++ cnt;        p = trie[p][x];        ans[p] ++;    &#125;&#125;int get(string s)&#123;    int p = 0, n = s.size();    rep(i, 0, n - 1)&#123;        int x = s[i] - &#39;0&#39;;        if(!trie[p][x]) return 0;        p = trie[p][x];    &#125;    return ans[p];&#125;void solve()&#123;    // 初始化    rep(i, 0, cnt)&#123;        ans[i] = 0;        rep(j, 0, 140) trie[i][j] = 0;    &#125; cnt = 0;    int n, q; cin &gt;&gt; n &gt;&gt; q;    rep(i, 1, n)&#123;        string s; cin &gt;&gt; s;        in(s);    &#125;    rep(i, 1, q)&#123;        string s; cin &gt;&gt; s;        cout &lt;&lt; get(s) &lt;&lt; &#39;\n&#39;;    &#125;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    while(n--) solve();    return 0;&#125;</code></pre><p>延申题下次再更新。。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做道板子&lt;/p&gt;</summary>
    
    
    
    <category term="Trie" scheme="https://www.ylq1104.cn/categories/Trie/"/>
    
    
    <category term="字符串" scheme="https://www.ylq1104.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>点分治</title>
    <link href="https://www.ylq1104.cn/posts/49220/"/>
    <id>https://www.ylq1104.cn/posts/49220/</id>
    <published>2023-02-16T04:59:45.000Z</published>
    <updated>2023-02-16T08:19:07.518Z</updated>
    
    <content type="html"><![CDATA[<p>水了一个寒假，快开学了QAQ</p><span id="more"></span><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>过度~~~</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>何为分治？</p><h2 id="分治："><a href="#分治：" class="headerlink" title="分治："></a>分治：</h2><blockquote><p>将一个大问题用类似于二分的手法将其分成一半进行递归求解。</p></blockquote><p>洛谷题 ：<a href="https://www.luogu.com.cn/problem/P1257">平面最近点对</a></p><blockquote><p>以该题为例: 求二维平面内n个点中的最短距离</p></blockquote><p>思路：<br>我们可以将该图以最中间的点的x值分为两个区域<br><img src="/picture/dfz1.png" class="lazyload placeholder" data-srcset="/picture/dfz1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>然后我们可以用分治的思想求最短距离d,其为两部分</p><blockquote><p>1 : 求每个部分中最短距离 d</p></blockquote><blockquote><p>2 : 求跨越两个区域的最短距离 d</p></blockquote><p>第一个部分我们很好理解，分治递归之。<br>第二个部分我们可以假设从已经从每个部分中得到一个最小距离d，我们假设中间点的坐标为 $x_1$，那么我们可以枚举 $x_1 - d &lt; x &lt;x_1 + d $ 的点查找是否有小于 $d$ 的值并更新。<br>因为对于以 $x_1$ 为中心，边长为 $d$ 的两个正方形， 显然枚举的点数一直在减小。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define rep(i, n, m) for(int i = n; i &lt;= m; ++i)#define per(i, n, m) for(int i = n; i &gt;= m; --i)using namespace std;const int N = 2e5 + 10;pair&lt;double, double&gt; p[N];double cal(pair&lt;double, double&gt; a, pair&lt;double, double&gt; b)&#123;    return sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));&#125;double get(int l, int r)&#123;    if(l == r) return INF;    if(l + 1 == r) return cal(p[l], p[r]);    int mid = l + r &gt;&gt; 1;    double x = p[mid].first;    double d = min(get(l, mid), get(mid + 1, r));    for(int i = mid; i &gt;= l &amp;&amp; x - p[i].first &lt; d; -- i)&#123;        for(int j = mid + 1; j &lt;= r &amp;&amp; p[j].first - x &lt; d; ++ j)&#123;            double res = cal(p[i], p[j]);            d = min(res, d);        &#125;    &#125;    return d;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    int n; cin &gt;&gt; n;    rep(i, 1, n)&#123;        cin &gt;&gt; p[i].first;        cin &gt;&gt; p[i].second;    &#125;    sort(p + 1, p + 1 + n);    printf(&quot;%.4lf&quot;, get(1, n));    return 0;&#125;</code></pre><p>然后回到正事<br>洛谷题：<a href="https://www.luogu.com.cn/problem/P3806">点分治</a></p><blockquote><p>题意：给定一棵 n 个节点的数，m 次询问每次问是否存在距离为 k 的点对</p></blockquote><p>思路：<br>对于一颗树，我们考虑选择一个根节点 $root$，那么删除该根节点后，就会出现若干棵子树<br>然后我们考虑的距离有两种：<br><img src="/picture/dfz2.png" class="lazyload placeholder" data-srcset="/picture/dfz2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>1 ：一颗子树中的两个节点之间的距离<br>2 ：两个属于不同子树的节点之间的距离，这个路径是经过根节点的。（如果有一个节点是根节点，那么可以看成第二种情况下一个节点到根节点的距离为 0）</p></blockquote><p>如果我们枚举每一个节点为根节点，那每一个递归层的复杂度是 $O(nlogn)$,如果一颗树的路径是一条线性链表的话，那复杂度就变成了$O(n^2logn)$，直接寄了，所以我们可以考虑找到一棵树的重心作为根节点，那么我们的复杂度就可以变成$O(nlog^2n)$</p><blockquote><p>（树的重心：它的子树的数量最大值最小）<br>我们可以用一个递归来找重心</p></blockquote><pre><code class="cpp">void get_root(int u, int pre, int sum)&#123;    siz[u] = 1; mx[u] = 0;    for(int i = head[u]; i; i = ne[i])&#123;        int to = e[i];        if(to == pre || vis[to]) continue; //如果当前点已经做过重心        get_root(to, u, sum);        siz[u] += siz[to]; //子树大小相加        mx[u] = max(mx[u], siz[to]); //找最大子树大小    &#125;    mx[u] = max(mx[u], sum - siz[u]); //当前子树外的所有点 sum - siz[u]    if(mx[u] &lt; mx[root] || !root) root = u; //如果最大子树大小比 mx[root]小就更新&#125;</code></pre><p>另外，在一个根节点下面的所有dist都知道了以后，如果两个点是同一颗子树中的，那他俩的dist相加肯定不是正确的路径长度，所以我们可以用一个col来标记当前节点属于哪一棵子树，最后我们二分该根节点下的所有节点，如果不属于同一颗子树且满足dist[l] + dist[r] == query[i] ，则答案存在</p><pre><code class="cpp">    sort(q + 1, q + 1 + tol, cmp); //我们对所有点按 到 根节点的距离长度排序    rep(i, 1, m)&#123;        int l = 1, r = tol;        if(ok[i]) continue;        while(l &lt; r)&#123;            int x = q[l], y = q[r];            if(dist[x] + dist[y] &lt; query[i])&#123;                 l ++;            &#125;else if(dist[x] + dist[y] &gt; query[i])&#123;                r --;            &#125;else if(col[x] == col[y])&#123;                if(col[y] == col[q[r - 1]]) r --;                else l ++;            &#125;else &#123;                ok[i] = 1;                break;            &#125;        &#125;    &#125;</code></pre><p>最终代码</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define rep(i, n, m) for(int i = n; i &lt;= m; ++i)#define per(i, n, m) for(int i = n; i &gt;= m; --i)using namespace std;const int N = 2e5 + 10;int ne[N], w[N], e[N], head[N], cnt = 0; //邻接表int n, m, root, ok[N], query[N], siz[N], mx[N], vis[N];int tol, q[N], dist[N], col[N];/*ok：是否存在点对满足解  query：每次询问的k值 siz：以当前为根节点的子树大小mx：以当前节点为根节点，其子树中大小的最小值 vis：当前节点是否当过重心tol：队列的大小， q：队列 dist：当前节点到根节点的距离 col：当前点属于哪棵子树*/void add(int a, int b, int c)&#123;    e[++cnt] = b, w[cnt] = c, ne[cnt] = head[a], head[a] = cnt; &#125;bool cmp(int a, int b)&#123;    return dist[a] &lt; dist[b];&#125;void get_root(int u, int pre, int sum)&#123;    siz[u] = 1; mx[u] = 0;    for(int i = head[u]; i; i = ne[i])&#123;        int to = e[i];        if(to == pre || vis[to]) continue;        get_root(to, u, sum);        siz[u] += siz[to];        mx[u] = max(mx[u], siz[to]);    &#125;    mx[u] = max(mx[u], sum - siz[u]);    if(mx[u] &lt; mx[root] || !root) root = u;&#125;void get_dist(int u, int pre, int dis, int camp)&#123;    q[++tol] = u;   // 入队列    dist[u] = dis;    col[u] = camp;  // u节点属于子树 camp    for(int i = head[u]; i; i = ne[i])&#123;        int to = e[i];        if(to == pre || vis[to]) continue;        get_dist(to, u, w[i] + dis, camp);    &#125;&#125;void cal(int u)&#123;    tol = 0;    q[++ tol] = u;    dist[u] = 0;    col[u] = u;    for(int i = head[u]; i ; i = ne[i])&#123;        int to = e[i];        if(!vis[to]) get_dist(to, u, w[i], to);    &#125;    sort(q + 1, q + 1 + tol, cmp);    rep(i, 1, m)&#123;        int l = 1, r = tol;        if(ok[i]) continue;        while(l &lt; r)&#123;            int x = q[l], y = q[r];            if(dist[x] + dist[y] &lt; query[i])&#123;                l ++;            &#125;else if(dist[x] + dist[y] &gt; query[i])&#123;                r --;            &#125;else if(col[x] == col[y])&#123;                if(col[y] == col[q[r - 1]]) r --;                else l ++;            &#125;else &#123;                ok[i] = 1;                break;            &#125;        &#125;    &#125;&#125;void solve(int u)&#123; // 分治    vis[u] = 1;    cal(u);    for(int i = head[u]; i; i = ne[i])&#123;        int to = e[i];        if(!vis[to])&#123;            root = 0;            get_root(to, 0, siz[to]);            solve(root);        &#125;    &#125;&#125;int main()&#123;    //ios::sync_with_stdio(0); cin.tie(0);    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n - 1)&#123;        int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        add(u, v, w); add(v, u, w);    &#125;    rep(i, 1, m)&#123;        cin &gt;&gt; query[i];    &#125;    mx[0] = n;    get_root(1, 0, n);    solve(root);    rep(i, 1, m)&#123;        if(ok[i]) cout &lt;&lt; &quot;AYE&quot; &lt;&lt; &#39;\n&#39;;        else cout &lt;&lt; &quot;NAY&quot; &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;/*4 41 2 32 3 23 4 12314*/</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;水了一个寒假，快开学了QAQ&lt;/p&gt;</summary>
    
    
    
    <category term="图论" scheme="https://www.ylq1104.cn/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="分治" scheme="https://www.ylq1104.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="递归" scheme="https://www.ylq1104.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
